{"ast":null,"code":"import stream from 'stream';\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar papaparse = createCommonjsModule(function (module, exports) {\n  /* @license\n  Papa Parse\n  v5.1.1\n  https://github.com/mholt/PapaParse\n  License: MIT\n  */\n  (function (root, factory) {\n    /* globals define */\n    {\n      // Node. Does not work with strict CommonJS, but\n      // only CommonJS-like environments that support module.exports,\n      // like Node.\n      module.exports = factory();\n    } // in strict mode we cannot access arguments.callee, so we need a named reference to\n    // stringify the factory method for the blob worker\n    // eslint-disable-next-line func-name\n  })(commonjsGlobal, function moduleFactory() {\n    var global = function () {\n      // alternative method, similar to `Function('return this')()`\n      // but without using `eval` (which is disabled when\n      // using Content Security Policy).\n      if (typeof self !== 'undefined') {\n        return self;\n      }\n\n      if (typeof window !== 'undefined') {\n        return window;\n      }\n\n      if (typeof global !== 'undefined') {\n        return global;\n      } // When running tests none of the above have been defined\n\n\n      return {};\n    }();\n\n    function getWorkerBlob() {\n      var URL = global.URL || global.webkitURL || null;\n      var code = moduleFactory.toString();\n      return Papa.BLOB_URL || (Papa.BLOB_URL = URL.createObjectURL(new Blob(['(', code, ')();'], {\n        type: 'text/javascript'\n      })));\n    }\n\n    var IS_WORKER = !global.document && !!global.postMessage,\n        IS_PAPA_WORKER = IS_WORKER && /blob:/i.test((global.location || {}).protocol);\n    var workers = {},\n        workerIdCounter = 0;\n    var Papa = {};\n    Papa.parse = CsvToJson;\n    Papa.unparse = JsonToCsv;\n    Papa.RECORD_SEP = String.fromCharCode(30);\n    Papa.UNIT_SEP = String.fromCharCode(31);\n    Papa.BYTE_ORDER_MARK = '\\ufeff';\n    Papa.BAD_DELIMITERS = ['\\r', '\\n', '\"', Papa.BYTE_ORDER_MARK];\n    Papa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker;\n    Papa.NODE_STREAM_INPUT = 1; // Configurable chunk sizes for local and remote files, respectively\n\n    Papa.LocalChunkSize = 1024 * 1024 * 10; // 10 MB\n\n    Papa.RemoteChunkSize = 1024 * 1024 * 5; // 5 MB\n\n    Papa.DefaultDelimiter = ','; // Used if not specified and detection fails\n    // Exposed for testing and development only\n\n    Papa.Parser = Parser;\n    Papa.ParserHandle = ParserHandle;\n    Papa.NetworkStreamer = NetworkStreamer;\n    Papa.FileStreamer = FileStreamer;\n    Papa.StringStreamer = StringStreamer;\n    Papa.ReadableStreamStreamer = ReadableStreamStreamer;\n\n    if (typeof PAPA_BROWSER_CONTEXT === 'undefined') {\n      Papa.DuplexStreamStreamer = DuplexStreamStreamer;\n    }\n\n    if (global.jQuery) {\n      var $ = global.jQuery;\n\n      $.fn.parse = function (options) {\n        var config = options.config || {};\n        var queue = [];\n        this.each(function (idx) {\n          var supported = $(this).prop('tagName').toUpperCase() === 'INPUT' && $(this).attr('type').toLowerCase() === 'file' && global.FileReader;\n          if (!supported || !this.files || this.files.length === 0) return true; // continue to next input element\n\n          for (var i = 0; i < this.files.length; i++) {\n            queue.push({\n              file: this.files[i],\n              inputElem: this,\n              instanceConfig: $.extend({}, config)\n            });\n          }\n        });\n        parseNextFile(); // begin parsing\n\n        return this; // maintains chainability\n\n        function parseNextFile() {\n          if (queue.length === 0) {\n            if (isFunction(options.complete)) options.complete();\n            return;\n          }\n\n          var f = queue[0];\n\n          if (isFunction(options.before)) {\n            var returned = options.before(f.file, f.inputElem);\n\n            if (typeof returned === 'object') {\n              if (returned.action === 'abort') {\n                error('AbortError', f.file, f.inputElem, returned.reason);\n                return; // Aborts all queued files immediately\n              } else if (returned.action === 'skip') {\n                fileComplete(); // parse the next file in the queue, if any\n\n                return;\n              } else if (typeof returned.config === 'object') f.instanceConfig = $.extend(f.instanceConfig, returned.config);\n            } else if (returned === 'skip') {\n              fileComplete(); // parse the next file in the queue, if any\n\n              return;\n            }\n          } // Wrap up the user's complete callback, if any, so that ours also gets executed\n\n\n          var userCompleteFunc = f.instanceConfig.complete;\n\n          f.instanceConfig.complete = function (results) {\n            if (isFunction(userCompleteFunc)) userCompleteFunc(results, f.file, f.inputElem);\n            fileComplete();\n          };\n\n          Papa.parse(f.file, f.instanceConfig);\n        }\n\n        function error(name, file, elem, reason) {\n          if (isFunction(options.error)) options.error({\n            name: name\n          }, file, elem, reason);\n        }\n\n        function fileComplete() {\n          queue.splice(0, 1);\n          parseNextFile();\n        }\n      };\n    }\n\n    if (IS_PAPA_WORKER) {\n      global.onmessage = workerThreadReceivedMessage;\n    }\n\n    function CsvToJson(_input, _config) {\n      _config = _config || {};\n      var dynamicTyping = _config.dynamicTyping || false;\n\n      if (isFunction(dynamicTyping)) {\n        _config.dynamicTypingFunction = dynamicTyping; // Will be filled on first row call\n\n        dynamicTyping = {};\n      }\n\n      _config.dynamicTyping = dynamicTyping;\n      _config.transform = isFunction(_config.transform) ? _config.transform : false;\n\n      if (_config.worker && Papa.WORKERS_SUPPORTED) {\n        var w = newWorker();\n        w.userStep = _config.step;\n        w.userChunk = _config.chunk;\n        w.userComplete = _config.complete;\n        w.userError = _config.error;\n        _config.step = isFunction(_config.step);\n        _config.chunk = isFunction(_config.chunk);\n        _config.complete = isFunction(_config.complete);\n        _config.error = isFunction(_config.error);\n        delete _config.worker; // prevent infinite loop\n\n        w.postMessage({\n          input: _input,\n          config: _config,\n          workerId: w.id\n        });\n        return;\n      }\n\n      var streamer = null;\n\n      if (_input === Papa.NODE_STREAM_INPUT && typeof PAPA_BROWSER_CONTEXT === 'undefined') {\n        // create a node Duplex stream for use\n        // with .pipe\n        streamer = new DuplexStreamStreamer(_config);\n        return streamer.getStream();\n      } else if (typeof _input === 'string') {\n        if (_config.download) streamer = new NetworkStreamer(_config);else streamer = new StringStreamer(_config);\n      } else if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on)) {\n        streamer = new ReadableStreamStreamer(_config);\n      } else if (global.File && _input instanceof File || _input instanceof Object) // ...Safari. (see issue #106)\n        streamer = new FileStreamer(_config);\n\n      return streamer.stream(_input);\n    }\n\n    function JsonToCsv(_input, _config) {\n      // Default configuration\n\n      /** whether to surround every datum with quotes */\n      var _quotes = false;\n      /** whether to write headers */\n\n      var _writeHeader = true;\n      /** delimiting character(s) */\n\n      var _delimiter = ',';\n      /** newline character(s) */\n\n      var _newline = '\\r\\n';\n      /** quote character */\n\n      var _quoteChar = '\"';\n      /** escaped quote character, either \"\" or <config.escapeChar>\" */\n\n      var _escapedQuote = _quoteChar + _quoteChar;\n      /** whether to skip empty lines */\n\n\n      var _skipEmptyLines = false;\n      /** the columns (keys) we expect when we unparse objects */\n\n      var _columns = null;\n      unpackConfig();\n      var quoteCharRegex = new RegExp(escapeRegExp(_quoteChar), 'g');\n      if (typeof _input === 'string') _input = JSON.parse(_input);\n\n      if (Array.isArray(_input)) {\n        if (!_input.length || Array.isArray(_input[0])) return serialize(null, _input, _skipEmptyLines);else if (typeof _input[0] === 'object') return serialize(_columns || objectKeys(_input[0]), _input, _skipEmptyLines);\n      } else if (typeof _input === 'object') {\n        if (typeof _input.data === 'string') _input.data = JSON.parse(_input.data);\n\n        if (Array.isArray(_input.data)) {\n          if (!_input.fields) _input.fields = _input.meta && _input.meta.fields;\n          if (!_input.fields) _input.fields = Array.isArray(_input.data[0]) ? _input.fields : objectKeys(_input.data[0]);\n          if (!Array.isArray(_input.data[0]) && typeof _input.data[0] !== 'object') _input.data = [_input.data]; // handles input like [1,2,3] or ['asdf']\n        }\n\n        return serialize(_input.fields || [], _input.data || [], _skipEmptyLines);\n      } // Default (any valid paths should return before this)\n\n\n      throw new Error('Unable to serialize unrecognized input');\n\n      function unpackConfig() {\n        if (typeof _config !== 'object') return;\n\n        if (typeof _config.delimiter === 'string' && !Papa.BAD_DELIMITERS.filter(function (value) {\n          return _config.delimiter.indexOf(value) !== -1;\n        }).length) {\n          _delimiter = _config.delimiter;\n        }\n\n        if (typeof _config.quotes === 'boolean' || typeof _config.quotes === 'function' || Array.isArray(_config.quotes)) _quotes = _config.quotes;\n        if (typeof _config.skipEmptyLines === 'boolean' || typeof _config.skipEmptyLines === 'string') _skipEmptyLines = _config.skipEmptyLines;\n        if (typeof _config.newline === 'string') _newline = _config.newline;\n        if (typeof _config.quoteChar === 'string') _quoteChar = _config.quoteChar;\n        if (typeof _config.header === 'boolean') _writeHeader = _config.header;\n\n        if (Array.isArray(_config.columns)) {\n          if (_config.columns.length === 0) throw new Error('Option columns is empty');\n          _columns = _config.columns;\n        }\n\n        if (_config.escapeChar !== undefined) {\n          _escapedQuote = _config.escapeChar + _quoteChar;\n        }\n      }\n      /** Turns an object's keys into an array */\n\n\n      function objectKeys(obj) {\n        if (typeof obj !== 'object') return [];\n        var keys = [];\n\n        for (var key in obj) keys.push(key);\n\n        return keys;\n      }\n      /** The double for loop that iterates the data and writes out a CSV string including header row */\n\n\n      function serialize(fields, data, skipEmptyLines) {\n        var csv = '';\n        if (typeof fields === 'string') fields = JSON.parse(fields);\n        if (typeof data === 'string') data = JSON.parse(data);\n        var hasHeader = Array.isArray(fields) && fields.length > 0;\n        var dataKeyedByField = !Array.isArray(data[0]); // If there a header row, write it first\n\n        if (hasHeader && _writeHeader) {\n          for (var i = 0; i < fields.length; i++) {\n            if (i > 0) csv += _delimiter;\n            csv += safe(fields[i], i);\n          }\n\n          if (data.length > 0) csv += _newline;\n        } // Then write out the data\n\n\n        for (var row = 0; row < data.length; row++) {\n          var maxCol = hasHeader ? fields.length : data[row].length;\n          var emptyLine = false;\n          var nullLine = hasHeader ? Object.keys(data[row]).length === 0 : data[row].length === 0;\n\n          if (skipEmptyLines && !hasHeader) {\n            emptyLine = skipEmptyLines === 'greedy' ? data[row].join('').trim() === '' : data[row].length === 1 && data[row][0].length === 0;\n          }\n\n          if (skipEmptyLines === 'greedy' && hasHeader) {\n            var line = [];\n\n            for (var c = 0; c < maxCol; c++) {\n              var cx = dataKeyedByField ? fields[c] : c;\n              line.push(data[row][cx]);\n            }\n\n            emptyLine = line.join('').trim() === '';\n          }\n\n          if (!emptyLine) {\n            for (var col = 0; col < maxCol; col++) {\n              if (col > 0 && !nullLine) csv += _delimiter;\n              var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;\n              csv += safe(data[row][colIdx], col);\n            }\n\n            if (row < data.length - 1 && (!skipEmptyLines || maxCol > 0 && !nullLine)) {\n              csv += _newline;\n            }\n          }\n        }\n\n        return csv;\n      }\n      /** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */\n\n\n      function safe(str, col) {\n        if (typeof str === 'undefined' || str === null) return '';\n        if (str.constructor === Date) return JSON.stringify(str).slice(1, 25);\n        var escapedQuoteStr = str.toString().replace(quoteCharRegex, _escapedQuote);\n        var needsQuotes = typeof _quotes === 'boolean' && _quotes || typeof _quotes === 'function' && _quotes(str, col) || Array.isArray(_quotes) && _quotes[col] || hasAny(escapedQuoteStr, Papa.BAD_DELIMITERS) || escapedQuoteStr.indexOf(_delimiter) > -1 || escapedQuoteStr.charAt(0) === ' ' || escapedQuoteStr.charAt(escapedQuoteStr.length - 1) === ' ';\n        return needsQuotes ? _quoteChar + escapedQuoteStr + _quoteChar : escapedQuoteStr;\n      }\n\n      function hasAny(str, substrings) {\n        for (var i = 0; i < substrings.length; i++) if (str.indexOf(substrings[i]) > -1) return true;\n\n        return false;\n      }\n    }\n    /** ChunkStreamer is the base prototype for various streamer implementations. */\n\n\n    function ChunkStreamer(config) {\n      this._handle = null;\n      this._finished = false;\n      this._completed = false;\n      this._halted = false;\n      this._input = null;\n      this._baseIndex = 0;\n      this._partialLine = '';\n      this._rowCount = 0;\n      this._start = 0;\n      this._nextChunk = null;\n      this.isFirstChunk = true;\n      this._completeResults = {\n        data: [],\n        errors: [],\n        meta: {}\n      };\n      replaceConfig.call(this, config);\n\n      this.parseChunk = function (chunk, isFakeChunk) {\n        // First chunk pre-processing\n        if (this.isFirstChunk && isFunction(this._config.beforeFirstChunk)) {\n          var modifiedChunk = this._config.beforeFirstChunk(chunk);\n\n          if (modifiedChunk !== undefined) chunk = modifiedChunk;\n        }\n\n        this.isFirstChunk = false;\n        this._halted = false; // Rejoin the line we likely just split in two by chunking the file\n\n        var aggregate = this._partialLine + chunk;\n        this._partialLine = '';\n\n        var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);\n\n        if (this._handle.paused() || this._handle.aborted()) {\n          this._halted = true;\n          return;\n        }\n\n        var lastIndex = results.meta.cursor;\n\n        if (!this._finished) {\n          this._partialLine = aggregate.substring(lastIndex - this._baseIndex);\n          this._baseIndex = lastIndex;\n        }\n\n        if (results && results.data) this._rowCount += results.data.length;\n        var finishedIncludingPreview = this._finished || this._config.preview && this._rowCount >= this._config.preview;\n\n        if (IS_PAPA_WORKER) {\n          global.postMessage({\n            results: results,\n            workerId: Papa.WORKER_ID,\n            finished: finishedIncludingPreview\n          });\n        } else if (isFunction(this._config.chunk) && !isFakeChunk) {\n          this._config.chunk(results, this._handle);\n\n          if (this._handle.paused() || this._handle.aborted()) {\n            this._halted = true;\n            return;\n          }\n\n          results = undefined;\n          this._completeResults = undefined;\n        }\n\n        if (!this._config.step && !this._config.chunk) {\n          this._completeResults.data = this._completeResults.data.concat(results.data);\n          this._completeResults.errors = this._completeResults.errors.concat(results.errors);\n          this._completeResults.meta = results.meta;\n        }\n\n        if (!this._completed && finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted)) {\n          this._config.complete(this._completeResults, this._input);\n\n          this._completed = true;\n        }\n\n        if (!finishedIncludingPreview && (!results || !results.meta.paused)) this._nextChunk();\n        return results;\n      };\n\n      this._sendError = function (error) {\n        if (isFunction(this._config.error)) this._config.error(error);else if (IS_PAPA_WORKER && this._config.error) {\n          global.postMessage({\n            workerId: Papa.WORKER_ID,\n            error: error,\n            finished: false\n          });\n        }\n      };\n\n      function replaceConfig(config) {\n        // Deep-copy the config so we can edit it\n        var configCopy = copy(config);\n        configCopy.chunkSize = parseInt(configCopy.chunkSize); // parseInt VERY important so we don't concatenate strings!\n\n        if (!config.step && !config.chunk) configCopy.chunkSize = null; // disable Range header if not streaming; bad values break IIS - see issue #196\n\n        this._handle = new ParserHandle(configCopy);\n        this._handle.streamer = this;\n        this._config = configCopy; // persist the copy to the caller\n      }\n    }\n\n    function NetworkStreamer(config) {\n      config = config || {};\n      if (!config.chunkSize) config.chunkSize = Papa.RemoteChunkSize;\n      ChunkStreamer.call(this, config);\n      var xhr;\n\n      if (IS_WORKER) {\n        this._nextChunk = function () {\n          this._readChunk();\n\n          this._chunkLoaded();\n        };\n      } else {\n        this._nextChunk = function () {\n          this._readChunk();\n        };\n      }\n\n      this.stream = function (url) {\n        this._input = url;\n\n        this._nextChunk(); // Starts streaming\n\n      };\n\n      this._readChunk = function () {\n        if (this._finished) {\n          this._chunkLoaded();\n\n          return;\n        }\n\n        xhr = new XMLHttpRequest();\n\n        if (this._config.withCredentials) {\n          xhr.withCredentials = this._config.withCredentials;\n        }\n\n        if (!IS_WORKER) {\n          xhr.onload = bindFunction(this._chunkLoaded, this);\n          xhr.onerror = bindFunction(this._chunkError, this);\n        }\n\n        xhr.open('GET', this._input, !IS_WORKER); // Headers can only be set when once the request state is OPENED\n\n        if (this._config.downloadRequestHeaders) {\n          var headers = this._config.downloadRequestHeaders;\n\n          for (var headerName in headers) {\n            xhr.setRequestHeader(headerName, headers[headerName]);\n          }\n        }\n\n        if (this._config.chunkSize) {\n          var end = this._start + this._config.chunkSize - 1; // minus one because byte range is inclusive\n\n          xhr.setRequestHeader('Range', 'bytes=' + this._start + '-' + end);\n        }\n\n        try {\n          xhr.send();\n        } catch (err) {\n          this._chunkError(err.message);\n        }\n\n        if (IS_WORKER && xhr.status === 0) this._chunkError();\n      };\n\n      this._chunkLoaded = function () {\n        if (xhr.readyState !== 4) return;\n\n        if (xhr.status < 200 || xhr.status >= 400) {\n          this._chunkError();\n\n          return;\n        } // Use chunckSize as it may be a diference on reponse lentgh due to characters with more than 1 byte\n\n\n        this._start += this._config.chunkSize ? this._config.chunkSize : xhr.responseText.length;\n        this._finished = !this._config.chunkSize || this._start >= getFileSize(xhr);\n        this.parseChunk(xhr.responseText);\n      };\n\n      this._chunkError = function (errorMessage) {\n        var errorText = xhr.statusText || errorMessage;\n\n        this._sendError(new Error(errorText));\n      };\n\n      function getFileSize(xhr) {\n        var contentRange = xhr.getResponseHeader('Content-Range');\n\n        if (contentRange === null) {\n          // no content range, then finish!\n          return -1;\n        }\n\n        return parseInt(contentRange.substring(contentRange.lastIndexOf('/') + 1));\n      }\n    }\n\n    NetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);\n    NetworkStreamer.prototype.constructor = NetworkStreamer;\n\n    function FileStreamer(config) {\n      config = config || {};\n      if (!config.chunkSize) config.chunkSize = Papa.LocalChunkSize;\n      ChunkStreamer.call(this, config);\n      var reader, slice; // FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862\n      // But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76\n\n      var usingAsyncReader = typeof FileReader !== 'undefined'; // Safari doesn't consider it a function - see issue #105\n\n      this.stream = function (file) {\n        this._input = file;\n        slice = file.slice || file.webkitSlice || file.mozSlice;\n\n        if (usingAsyncReader) {\n          reader = new FileReader(); // Preferred method of reading files, even in workers\n\n          reader.onload = bindFunction(this._chunkLoaded, this);\n          reader.onerror = bindFunction(this._chunkError, this);\n        } else reader = new FileReaderSync(); // Hack for running in a web worker in Firefox\n\n\n        this._nextChunk(); // Starts streaming\n\n      };\n\n      this._nextChunk = function () {\n        if (!this._finished && (!this._config.preview || this._rowCount < this._config.preview)) this._readChunk();\n      };\n\n      this._readChunk = function () {\n        var input = this._input;\n\n        if (this._config.chunkSize) {\n          var end = Math.min(this._start + this._config.chunkSize, this._input.size);\n          input = slice.call(input, this._start, end);\n        }\n\n        var txt = reader.readAsText(input, this._config.encoding);\n        if (!usingAsyncReader) this._chunkLoaded({\n          target: {\n            result: txt\n          }\n        }); // mimic the async signature\n      };\n\n      this._chunkLoaded = function (event) {\n        // Very important to increment start each time before handling results\n        this._start += this._config.chunkSize;\n        this._finished = !this._config.chunkSize || this._start >= this._input.size;\n        this.parseChunk(event.target.result);\n      };\n\n      this._chunkError = function () {\n        this._sendError(reader.error);\n      };\n    }\n\n    FileStreamer.prototype = Object.create(ChunkStreamer.prototype);\n    FileStreamer.prototype.constructor = FileStreamer;\n\n    function StringStreamer(config) {\n      config = config || {};\n      ChunkStreamer.call(this, config);\n      var remaining;\n\n      this.stream = function (s) {\n        remaining = s;\n        return this._nextChunk();\n      };\n\n      this._nextChunk = function () {\n        if (this._finished) return;\n        var size = this._config.chunkSize;\n        var chunk;\n\n        if (size) {\n          chunk = remaining.substring(0, size);\n          remaining = remaining.substring(size);\n        } else {\n          chunk = remaining;\n          remaining = '';\n        }\n\n        this._finished = !remaining;\n        return this.parseChunk(chunk);\n      };\n    }\n\n    StringStreamer.prototype = Object.create(StringStreamer.prototype);\n    StringStreamer.prototype.constructor = StringStreamer;\n\n    function ReadableStreamStreamer(config) {\n      config = config || {};\n      ChunkStreamer.call(this, config);\n      var queue = [];\n      var parseOnData = true;\n      var streamHasEnded = false;\n\n      this.pause = function () {\n        ChunkStreamer.prototype.pause.apply(this, arguments);\n\n        this._input.pause();\n      };\n\n      this.resume = function () {\n        ChunkStreamer.prototype.resume.apply(this, arguments);\n\n        this._input.resume();\n      };\n\n      this.stream = function (stream) {\n        this._input = stream;\n\n        this._input.on('data', this._streamData);\n\n        this._input.on('end', this._streamEnd);\n\n        this._input.on('error', this._streamError);\n      };\n\n      this._checkIsFinished = function () {\n        if (streamHasEnded && queue.length === 1) {\n          this._finished = true;\n        }\n      };\n\n      this._nextChunk = function () {\n        this._checkIsFinished();\n\n        if (queue.length) {\n          this.parseChunk(queue.shift());\n        } else {\n          parseOnData = true;\n        }\n      };\n\n      this._streamData = bindFunction(function (chunk) {\n        try {\n          queue.push(typeof chunk === 'string' ? chunk : chunk.toString(this._config.encoding));\n\n          if (parseOnData) {\n            parseOnData = false;\n\n            this._checkIsFinished();\n\n            this.parseChunk(queue.shift());\n          }\n        } catch (error) {\n          this._streamError(error);\n        }\n      }, this);\n      this._streamError = bindFunction(function (error) {\n        this._streamCleanUp();\n\n        this._sendError(error);\n      }, this);\n      this._streamEnd = bindFunction(function () {\n        this._streamCleanUp();\n\n        streamHasEnded = true;\n\n        this._streamData('');\n      }, this);\n      this._streamCleanUp = bindFunction(function () {\n        this._input.removeListener('data', this._streamData);\n\n        this._input.removeListener('end', this._streamEnd);\n\n        this._input.removeListener('error', this._streamError);\n      }, this);\n    }\n\n    ReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n    ReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;\n\n    function DuplexStreamStreamer(_config) {\n      var Duplex = stream.Duplex;\n      var config = copy(_config);\n      var parseOnWrite = true;\n      var writeStreamHasFinished = false;\n      var parseCallbackQueue = [];\n      var stream$1 = null;\n\n      this._onCsvData = function (results) {\n        var data = results.data;\n\n        if (!stream$1.push(data) && !this._handle.paused()) {\n          // the writeable consumer buffer has filled up\n          // so we need to pause until more items\n          // can be processed\n          this._handle.pause();\n        }\n      };\n\n      this._onCsvComplete = function () {\n        // node will finish the read stream when\n        // null is pushed\n        stream$1.push(null);\n      };\n\n      config.step = bindFunction(this._onCsvData, this);\n      config.complete = bindFunction(this._onCsvComplete, this);\n      ChunkStreamer.call(this, config);\n\n      this._nextChunk = function () {\n        if (writeStreamHasFinished && parseCallbackQueue.length === 1) {\n          this._finished = true;\n        }\n\n        if (parseCallbackQueue.length) {\n          parseCallbackQueue.shift()();\n        } else {\n          parseOnWrite = true;\n        }\n      };\n\n      this._addToParseQueue = function (chunk, callback) {\n        // add to queue so that we can indicate\n        // completion via callback\n        // node will automatically pause the incoming stream\n        // when too many items have been added without their\n        // callback being invoked\n        parseCallbackQueue.push(bindFunction(function () {\n          this.parseChunk(typeof chunk === 'string' ? chunk : chunk.toString(config.encoding));\n\n          if (isFunction(callback)) {\n            return callback();\n          }\n        }, this));\n\n        if (parseOnWrite) {\n          parseOnWrite = false;\n\n          this._nextChunk();\n        }\n      };\n\n      this._onRead = function () {\n        if (this._handle.paused()) {\n          // the writeable consumer can handle more data\n          // so resume the chunk parsing\n          this._handle.resume();\n        }\n      };\n\n      this._onWrite = function (chunk, encoding, callback) {\n        this._addToParseQueue(chunk, callback);\n      };\n\n      this._onWriteComplete = function () {\n        writeStreamHasFinished = true; // have to write empty string\n        // so parser knows its done\n\n        this._addToParseQueue('');\n      };\n\n      this.getStream = function () {\n        return stream$1;\n      };\n\n      stream$1 = new Duplex({\n        readableObjectMode: true,\n        decodeStrings: false,\n        read: bindFunction(this._onRead, this),\n        write: bindFunction(this._onWrite, this)\n      });\n      stream$1.once('finish', bindFunction(this._onWriteComplete, this));\n    }\n\n    if (typeof PAPA_BROWSER_CONTEXT === 'undefined') {\n      DuplexStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n      DuplexStreamStreamer.prototype.constructor = DuplexStreamStreamer;\n    } // Use one ParserHandle per entire CSV file or string\n\n\n    function ParserHandle(_config) {\n      // One goal is to minimize the use of regular expressions...\n      var MAX_FLOAT = Math.pow(2, 53);\n      var MIN_FLOAT = -MAX_FLOAT;\n      var FLOAT = /^\\s*-?(\\d*\\.?\\d+|\\d+\\.?\\d*)(e[-+]?\\d+)?\\s*$/i;\n      var ISO_DATE = /(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/;\n      var self = this;\n      var _stepCounter = 0; // Number of times step was called (number of rows parsed)\n\n      var _rowCounter = 0; // Number of rows that have been parsed so far\n\n      var _input; // The input being parsed\n\n\n      var _parser; // The core parser being used\n\n\n      var _paused = false; // Whether we are paused or not\n\n      var _aborted = false; // Whether the parser has aborted or not\n\n      var _delimiterError; // Temporary state between delimiter detection and processing results\n\n\n      var _fields = []; // Fields are from the header row of the input, if there is one\n\n      var _results = {\n        // The last results returned from the parser\n        data: [],\n        errors: [],\n        meta: {}\n      };\n\n      if (isFunction(_config.step)) {\n        var userStep = _config.step;\n\n        _config.step = function (results) {\n          _results = results;\n          if (needsHeaderRow()) processResults();else // only call user's step function after header row\n            {\n              processResults(); // It's possbile that this line was empty and there's no row here after all\n\n              if (_results.data.length === 0) return;\n              _stepCounter += results.data.length;\n              if (_config.preview && _stepCounter > _config.preview) _parser.abort();else {\n                _results.data = _results.data[0];\n                userStep(_results, self);\n              }\n            }\n        };\n      }\n      /**\n       * Parses input. Most users won't need, and shouldn't mess with, the baseIndex\n       * and ignoreLastRow parameters. They are used by streamers (wrapper functions)\n       * when an input comes in multiple chunks, like from a file.\n       */\n\n\n      this.parse = function (input, baseIndex, ignoreLastRow) {\n        var quoteChar = _config.quoteChar || '\"';\n        if (!_config.newline) _config.newline = guessLineEndings(input, quoteChar);\n        _delimiterError = false;\n\n        if (!_config.delimiter) {\n          var delimGuess = guessDelimiter(input, _config.newline, _config.skipEmptyLines, _config.comments, _config.delimitersToGuess);\n          if (delimGuess.successful) _config.delimiter = delimGuess.bestDelimiter;else {\n            _delimiterError = true; // add error after parsing (otherwise it would be overwritten)\n\n            _config.delimiter = Papa.DefaultDelimiter;\n          }\n          _results.meta.delimiter = _config.delimiter;\n        } else if (isFunction(_config.delimiter)) {\n          _config.delimiter = _config.delimiter(input);\n          _results.meta.delimiter = _config.delimiter;\n        }\n\n        var parserConfig = copy(_config);\n        if (_config.preview && _config.header) parserConfig.preview++; // to compensate for header row\n\n        _input = input;\n        _parser = new Parser(parserConfig);\n        _results = _parser.parse(_input, baseIndex, ignoreLastRow);\n        processResults();\n        return _paused ? {\n          meta: {\n            paused: true\n          }\n        } : _results || {\n          meta: {\n            paused: false\n          }\n        };\n      };\n\n      this.paused = function () {\n        return _paused;\n      };\n\n      this.pause = function () {\n        _paused = true;\n\n        _parser.abort(); // If it is streaming via \"chunking\", the reader will start appending correctly already so no need to substring,\n        // otherwise we can get duplicate content within a row\n\n\n        _input = isFunction(_config.chunk) ? \"\" : _input.substring(_parser.getCharIndex());\n      };\n\n      this.resume = function () {\n        if (self.streamer._halted) {\n          _paused = false;\n          self.streamer.parseChunk(_input, true);\n        } else {\n          // Bugfix: #636 In case the processing hasn't halted yet\n          // wait for it to halt in order to resume\n          setTimeout(this.resume, 3);\n        }\n      };\n\n      this.aborted = function () {\n        return _aborted;\n      };\n\n      this.abort = function () {\n        _aborted = true;\n\n        _parser.abort();\n\n        _results.meta.aborted = true;\n        if (isFunction(_config.complete)) _config.complete(_results);\n        _input = '';\n      };\n\n      function testEmptyLine(s) {\n        return _config.skipEmptyLines === 'greedy' ? s.join('').trim() === '' : s.length === 1 && s[0].length === 0;\n      }\n\n      function testFloat(s) {\n        if (FLOAT.test(s)) {\n          var floatValue = parseFloat(s);\n\n          if (floatValue > MIN_FLOAT && floatValue < MAX_FLOAT) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      function processResults() {\n        if (_results && _delimiterError) {\n          addError('Delimiter', 'UndetectableDelimiter', 'Unable to auto-detect delimiting character; defaulted to \\'' + Papa.DefaultDelimiter + '\\'');\n          _delimiterError = false;\n        }\n\n        if (_config.skipEmptyLines) {\n          for (var i = 0; i < _results.data.length; i++) if (testEmptyLine(_results.data[i])) _results.data.splice(i--, 1);\n        }\n\n        if (needsHeaderRow()) fillHeaderFields();\n        return applyHeaderAndDynamicTypingAndTransformation();\n      }\n\n      function needsHeaderRow() {\n        return _config.header && _fields.length === 0;\n      }\n\n      function fillHeaderFields() {\n        if (!_results) return;\n\n        function addHeder(header) {\n          if (isFunction(_config.transformHeader)) header = _config.transformHeader(header);\n\n          _fields.push(header);\n        }\n\n        if (Array.isArray(_results.data[0])) {\n          for (var i = 0; needsHeaderRow() && i < _results.data.length; i++) _results.data[i].forEach(addHeder);\n\n          _results.data.splice(0, 1);\n        } // if _results.data[0] is not an array, we are in a step where _results.data is the row.\n        else _results.data.forEach(addHeder);\n      }\n\n      function shouldApplyDynamicTyping(field) {\n        // Cache function values to avoid calling it for each row\n        if (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {\n          _config.dynamicTyping[field] = _config.dynamicTypingFunction(field);\n        }\n\n        return (_config.dynamicTyping[field] || _config.dynamicTyping) === true;\n      }\n\n      function parseDynamic(field, value) {\n        if (shouldApplyDynamicTyping(field)) {\n          if (value === 'true' || value === 'TRUE') return true;else if (value === 'false' || value === 'FALSE') return false;else if (testFloat(value)) return parseFloat(value);else if (ISO_DATE.test(value)) return new Date(value);else return value === '' ? null : value;\n        }\n\n        return value;\n      }\n\n      function applyHeaderAndDynamicTypingAndTransformation() {\n        if (!_results || !_config.header && !_config.dynamicTyping && !_config.transform) return _results;\n\n        function processRow(rowSource, i) {\n          var row = _config.header ? {} : [];\n          var j;\n\n          for (j = 0; j < rowSource.length; j++) {\n            var field = j;\n            var value = rowSource[j];\n            if (_config.header) field = j >= _fields.length ? '__parsed_extra' : _fields[j];\n            if (_config.transform) value = _config.transform(value, field);\n            value = parseDynamic(field, value);\n\n            if (field === '__parsed_extra') {\n              row[field] = row[field] || [];\n              row[field].push(value);\n            } else row[field] = value;\n          }\n\n          if (_config.header) {\n            if (j > _fields.length) addError('FieldMismatch', 'TooManyFields', 'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j, _rowCounter + i);else if (j < _fields.length) addError('FieldMismatch', 'TooFewFields', 'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j, _rowCounter + i);\n          }\n\n          return row;\n        }\n\n        var incrementBy = 1;\n\n        if (!_results.data.length || Array.isArray(_results.data[0])) {\n          _results.data = _results.data.map(processRow);\n          incrementBy = _results.data.length;\n        } else _results.data = processRow(_results.data, 0);\n\n        if (_config.header && _results.meta) _results.meta.fields = _fields;\n        _rowCounter += incrementBy;\n        return _results;\n      }\n\n      function guessDelimiter(input, newline, skipEmptyLines, comments, delimitersToGuess) {\n        var bestDelim, bestDelta, fieldCountPrevRow, maxFieldCount;\n        delimitersToGuess = delimitersToGuess || [',', '\\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];\n\n        for (var i = 0; i < delimitersToGuess.length; i++) {\n          var delim = delimitersToGuess[i];\n          var delta = 0,\n              avgFieldCount = 0,\n              emptyLinesCount = 0;\n          fieldCountPrevRow = undefined;\n          var preview = new Parser({\n            comments: comments,\n            delimiter: delim,\n            newline: newline,\n            preview: 10\n          }).parse(input);\n\n          for (var j = 0; j < preview.data.length; j++) {\n            if (skipEmptyLines && testEmptyLine(preview.data[j])) {\n              emptyLinesCount++;\n              continue;\n            }\n\n            var fieldCount = preview.data[j].length;\n            avgFieldCount += fieldCount;\n\n            if (typeof fieldCountPrevRow === 'undefined') {\n              fieldCountPrevRow = fieldCount;\n              continue;\n            } else if (fieldCount > 0) {\n              delta += Math.abs(fieldCount - fieldCountPrevRow);\n              fieldCountPrevRow = fieldCount;\n            }\n          }\n\n          if (preview.data.length > 0) avgFieldCount /= preview.data.length - emptyLinesCount;\n\n          if ((typeof bestDelta === 'undefined' || delta <= bestDelta) && (typeof maxFieldCount === 'undefined' || avgFieldCount > maxFieldCount) && avgFieldCount > 1.99) {\n            bestDelta = delta;\n            bestDelim = delim;\n            maxFieldCount = avgFieldCount;\n          }\n        }\n\n        _config.delimiter = bestDelim;\n        return {\n          successful: !!bestDelim,\n          bestDelimiter: bestDelim\n        };\n      }\n\n      function guessLineEndings(input, quoteChar) {\n        input = input.substring(0, 1024 * 1024); // max length 1 MB\n        // Replace all the text inside quotes\n\n        var re = new RegExp(escapeRegExp(quoteChar) + '([^]*?)' + escapeRegExp(quoteChar), 'gm');\n        input = input.replace(re, '');\n        var r = input.split('\\r');\n        var n = input.split('\\n');\n        var nAppearsFirst = n.length > 1 && n[0].length < r[0].length;\n        if (r.length === 1 || nAppearsFirst) return '\\n';\n        var numWithN = 0;\n\n        for (var i = 0; i < r.length; i++) {\n          if (r[i][0] === '\\n') numWithN++;\n        }\n\n        return numWithN >= r.length / 2 ? '\\r\\n' : '\\r';\n      }\n\n      function addError(type, code, msg, row) {\n        var error = {\n          type: type,\n          code: code,\n          message: msg\n        };\n\n        if (row !== undefined) {\n          error.row = row;\n        }\n\n        _results.errors.push(error);\n      }\n    }\n    /** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions */\n\n\n    function escapeRegExp(string) {\n      return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n    }\n    /** The core parser implements speedy and correct CSV parsing */\n\n\n    function Parser(config) {\n      // Unpack the config object\n      config = config || {};\n      var delim = config.delimiter;\n      var newline = config.newline;\n      var comments = config.comments;\n      var step = config.step;\n      var preview = config.preview;\n      var fastMode = config.fastMode;\n      var quoteChar;\n      /** Allows for no quoteChar by setting quoteChar to undefined in config */\n\n      if (config.quoteChar === undefined) {\n        quoteChar = '\"';\n      } else {\n        quoteChar = config.quoteChar;\n      }\n\n      var escapeChar = quoteChar;\n\n      if (config.escapeChar !== undefined) {\n        escapeChar = config.escapeChar;\n      } // Delimiter must be valid\n\n\n      if (typeof delim !== 'string' || Papa.BAD_DELIMITERS.indexOf(delim) > -1) delim = ','; // Comment character must be valid\n\n      if (comments === delim) throw new Error('Comment character same as delimiter');else if (comments === true) comments = '#';else if (typeof comments !== 'string' || Papa.BAD_DELIMITERS.indexOf(comments) > -1) comments = false; // Newline must be valid: \\r, \\n, or \\r\\n\n\n      if (newline !== '\\n' && newline !== '\\r' && newline !== '\\r\\n') newline = '\\n'; // We're gonna need these at the Parser scope\n\n      var cursor = 0;\n      var aborted = false;\n\n      this.parse = function (input, baseIndex, ignoreLastRow) {\n        // For some reason, in Chrome, this speeds things up (!?)\n        if (typeof input !== 'string') throw new Error('Input must be a string'); // We don't need to compute some of these every time parse() is called,\n        // but having them in a more local scope seems to perform better\n\n        var inputLen = input.length,\n            delimLen = delim.length,\n            newlineLen = newline.length,\n            commentsLen = comments.length;\n        var stepIsFunction = isFunction(step); // Establish starting state\n\n        cursor = 0;\n        var data = [],\n            errors = [],\n            row = [],\n            lastCursor = 0;\n        if (!input) return returnable();\n\n        if (fastMode || fastMode !== false && input.indexOf(quoteChar) === -1) {\n          var rows = input.split(newline);\n\n          for (var i = 0; i < rows.length; i++) {\n            row = rows[i];\n            cursor += row.length;\n            if (i !== rows.length - 1) cursor += newline.length;else if (ignoreLastRow) return returnable();\n            if (comments && row.substring(0, commentsLen) === comments) continue;\n\n            if (stepIsFunction) {\n              data = [];\n              pushRow(row.split(delim));\n              doStep();\n              if (aborted) return returnable();\n            } else pushRow(row.split(delim));\n\n            if (preview && i >= preview) {\n              data = data.slice(0, preview);\n              return returnable(true);\n            }\n          }\n\n          return returnable();\n        }\n\n        var nextDelim = input.indexOf(delim, cursor);\n        var nextNewline = input.indexOf(newline, cursor);\n        var quoteCharRegex = new RegExp(escapeRegExp(escapeChar) + escapeRegExp(quoteChar), 'g');\n        var quoteSearch = input.indexOf(quoteChar, cursor); // Parser loop\n\n        for (;;) {\n          // Field has opening quote\n          if (input[cursor] === quoteChar) {\n            // Start our search for the closing quote where the cursor is\n            quoteSearch = cursor; // Skip the opening quote\n\n            cursor++;\n\n            for (;;) {\n              // Find closing quote\n              quoteSearch = input.indexOf(quoteChar, quoteSearch + 1); //No other quotes are found - no other delimiters\n\n              if (quoteSearch === -1) {\n                if (!ignoreLastRow) {\n                  // No closing quote... what a pity\n                  errors.push({\n                    type: 'Quotes',\n                    code: 'MissingQuotes',\n                    message: 'Quoted field unterminated',\n                    row: data.length,\n                    // row has yet to be inserted\n                    index: cursor\n                  });\n                }\n\n                return finish();\n              } // Closing quote at EOF\n\n\n              if (quoteSearch === inputLen - 1) {\n                var value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);\n                return finish(value);\n              } // If this quote is escaped, it's part of the data; skip it\n              // If the quote character is the escape character, then check if the next character is the escape character\n\n\n              if (quoteChar === escapeChar && input[quoteSearch + 1] === escapeChar) {\n                quoteSearch++;\n                continue;\n              } // If the quote character is not the escape character, then check if the previous character was the escape character\n\n\n              if (quoteChar !== escapeChar && quoteSearch !== 0 && input[quoteSearch - 1] === escapeChar) {\n                continue;\n              }\n\n              if (nextDelim !== -1 && nextDelim < quoteSearch + 1) {\n                nextDelim = input.indexOf(delim, quoteSearch + 1);\n              }\n\n              if (nextNewline !== -1 && nextNewline < quoteSearch + 1) {\n                nextNewline = input.indexOf(newline, quoteSearch + 1);\n              } // Check up to nextDelim or nextNewline, whichever is closest\n\n\n              var checkUpTo = nextNewline === -1 ? nextDelim : Math.min(nextDelim, nextNewline);\n              var spacesBetweenQuoteAndDelimiter = extraSpaces(checkUpTo); // Closing quote followed by delimiter or 'unnecessary spaces + delimiter'\n\n              if (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter] === delim) {\n                row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n                cursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen; // If char after following delimiter is not quoteChar, we find next quote char position\n\n                if (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen] !== quoteChar) {\n                  quoteSearch = input.indexOf(quoteChar, cursor);\n                }\n\n                nextDelim = input.indexOf(delim, cursor);\n                nextNewline = input.indexOf(newline, cursor);\n                break;\n              }\n\n              var spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline); // Closing quote followed by newline or 'unnecessary spaces + newLine'\n\n              if (input.substring(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen) === newline) {\n                row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n                saveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);\n                nextDelim = input.indexOf(delim, cursor); // because we may have skipped the nextDelim in the quoted field\n\n                quoteSearch = input.indexOf(quoteChar, cursor); // we search for first quote in next line\n\n                if (stepIsFunction) {\n                  doStep();\n                  if (aborted) return returnable();\n                }\n\n                if (preview && data.length >= preview) return returnable(true);\n                break;\n              } // Checks for valid closing quotes are complete (escaped quotes or quote followed by EOF/delimiter/newline) -- assume these quotes are part of an invalid text string\n\n\n              errors.push({\n                type: 'Quotes',\n                code: 'InvalidQuotes',\n                message: 'Trailing quote on quoted field is malformed',\n                row: data.length,\n                // row has yet to be inserted\n                index: cursor\n              });\n              quoteSearch++;\n              continue;\n            }\n\n            continue;\n          } // Comment found at start of new line\n\n\n          if (comments && row.length === 0 && input.substring(cursor, cursor + commentsLen) === comments) {\n            if (nextNewline === -1) // Comment ends at EOF\n              return returnable();\n            cursor = nextNewline + newlineLen;\n            nextNewline = input.indexOf(newline, cursor);\n            nextDelim = input.indexOf(delim, cursor);\n            continue;\n          } // Next delimiter comes before next newline, so we've reached end of field\n\n\n          if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1)) {\n            // we check, if we have quotes, because delimiter char may be part of field enclosed in quotes\n            if (quoteSearch > nextDelim) {\n              // we have quotes, so we try to find the next delimiter not enclosed in quotes and also next starting quote char\n              var nextDelimObj = getNextUnquotedDelimiter(nextDelim, quoteSearch, nextNewline); // if we have next delimiter char which is not enclosed in quotes\n\n              if (nextDelimObj && typeof nextDelimObj.nextDelim !== 'undefined') {\n                nextDelim = nextDelimObj.nextDelim;\n                quoteSearch = nextDelimObj.quoteSearch;\n                row.push(input.substring(cursor, nextDelim));\n                cursor = nextDelim + delimLen; // we look for next delimiter char\n\n                nextDelim = input.indexOf(delim, cursor);\n                continue;\n              }\n            } else {\n              row.push(input.substring(cursor, nextDelim));\n              cursor = nextDelim + delimLen;\n              nextDelim = input.indexOf(delim, cursor);\n              continue;\n            }\n          } // End of row\n\n\n          if (nextNewline !== -1) {\n            row.push(input.substring(cursor, nextNewline));\n            saveRow(nextNewline + newlineLen);\n\n            if (stepIsFunction) {\n              doStep();\n              if (aborted) return returnable();\n            }\n\n            if (preview && data.length >= preview) return returnable(true);\n            continue;\n          }\n\n          break;\n        }\n\n        return finish();\n\n        function pushRow(row) {\n          data.push(row);\n          lastCursor = cursor;\n        }\n        /**\n                  * checks if there are extra spaces after closing quote and given index without any text\n                  * if Yes, returns the number of spaces\n                  */\n\n\n        function extraSpaces(index) {\n          var spaceLength = 0;\n\n          if (index !== -1) {\n            var textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index);\n\n            if (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === '') {\n              spaceLength = textBetweenClosingQuoteAndIndex.length;\n            }\n          }\n\n          return spaceLength;\n        }\n        /**\n         * Appends the remaining input from cursor to the end into\n         * row, saves the row, calls step, and returns the results.\n         */\n\n\n        function finish(value) {\n          if (ignoreLastRow) return returnable();\n          if (typeof value === 'undefined') value = input.substring(cursor);\n          row.push(value);\n          cursor = inputLen; // important in case parsing is paused\n\n          pushRow(row);\n          if (stepIsFunction) doStep();\n          return returnable();\n        }\n        /**\n         * Appends the current row to the results. It sets the cursor\n         * to newCursor and finds the nextNewline. The caller should\n         * take care to execute user's step function and check for\n         * preview and end parsing if necessary.\n         */\n\n\n        function saveRow(newCursor) {\n          cursor = newCursor;\n          pushRow(row);\n          row = [];\n          nextNewline = input.indexOf(newline, cursor);\n        }\n        /** Returns an object with the results, errors, and meta. */\n\n\n        function returnable(stopped) {\n          return {\n            data: data,\n            errors: errors,\n            meta: {\n              delimiter: delim,\n              linebreak: newline,\n              aborted: aborted,\n              truncated: !!stopped,\n              cursor: lastCursor + (baseIndex || 0)\n            }\n          };\n        }\n        /** Executes the user's step function and resets data & errors. */\n\n\n        function doStep() {\n          step(returnable());\n          data = [];\n          errors = [];\n        }\n        /** Gets the delimiter character, which is not inside the quoted field */\n\n\n        function getNextUnquotedDelimiter(nextDelim, quoteSearch, newLine) {\n          var result = {\n            nextDelim: undefined,\n            quoteSearch: undefined\n          }; // get the next closing quote character\n\n          var nextQuoteSearch = input.indexOf(quoteChar, quoteSearch + 1); // if next delimiter is part of a field enclosed in quotes\n\n          if (nextDelim > quoteSearch && nextDelim < nextQuoteSearch && (nextQuoteSearch < newLine || newLine === -1)) {\n            // get the next delimiter character after this one\n            var nextNextDelim = input.indexOf(delim, nextQuoteSearch); // if there is no next delimiter, return default result\n\n            if (nextNextDelim === -1) {\n              return result;\n            } // find the next opening quote char position\n\n\n            if (nextNextDelim > nextQuoteSearch) {\n              nextQuoteSearch = input.indexOf(quoteChar, nextQuoteSearch + 1);\n            } // try to get the next delimiter position\n\n\n            result = getNextUnquotedDelimiter(nextNextDelim, nextQuoteSearch, newLine);\n          } else {\n            result = {\n              nextDelim: nextDelim,\n              quoteSearch: quoteSearch\n            };\n          }\n\n          return result;\n        }\n      };\n      /** Sets the abort flag */\n\n\n      this.abort = function () {\n        aborted = true;\n      };\n      /** Gets the cursor position */\n\n\n      this.getCharIndex = function () {\n        return cursor;\n      };\n    }\n\n    function newWorker() {\n      if (!Papa.WORKERS_SUPPORTED) return false;\n      var workerUrl = getWorkerBlob();\n      var w = new global.Worker(workerUrl);\n      w.onmessage = mainThreadReceivedMessage;\n      w.id = workerIdCounter++;\n      workers[w.id] = w;\n      return w;\n    }\n    /** Callback when main thread receives a message */\n\n\n    function mainThreadReceivedMessage(e) {\n      var msg = e.data;\n      var worker = workers[msg.workerId];\n      var aborted = false;\n      if (msg.error) worker.userError(msg.error, msg.file);else if (msg.results && msg.results.data) {\n        var abort = function () {\n          aborted = true;\n          completeWorker(msg.workerId, {\n            data: [],\n            errors: [],\n            meta: {\n              aborted: true\n            }\n          });\n        };\n\n        var handle = {\n          abort: abort,\n          pause: notImplemented,\n          resume: notImplemented\n        };\n\n        if (isFunction(worker.userStep)) {\n          for (var i = 0; i < msg.results.data.length; i++) {\n            worker.userStep({\n              data: msg.results.data[i],\n              errors: msg.results.errors,\n              meta: msg.results.meta\n            }, handle);\n            if (aborted) break;\n          }\n\n          delete msg.results; // free memory ASAP\n        } else if (isFunction(worker.userChunk)) {\n          worker.userChunk(msg.results, handle, msg.file);\n          delete msg.results;\n        }\n      }\n      if (msg.finished && !aborted) completeWorker(msg.workerId, msg.results);\n    }\n\n    function completeWorker(workerId, results) {\n      var worker = workers[workerId];\n      if (isFunction(worker.userComplete)) worker.userComplete(results);\n      worker.terminate();\n      delete workers[workerId];\n    }\n\n    function notImplemented() {\n      throw new Error('Not implemented.');\n    }\n    /** Callback when worker thread receives a message */\n\n\n    function workerThreadReceivedMessage(e) {\n      var msg = e.data;\n      if (typeof Papa.WORKER_ID === 'undefined' && msg) Papa.WORKER_ID = msg.workerId;\n\n      if (typeof msg.input === 'string') {\n        global.postMessage({\n          workerId: Papa.WORKER_ID,\n          results: Papa.parse(msg.input, msg.config),\n          finished: true\n        });\n      } else if (global.File && msg.input instanceof File || msg.input instanceof Object) // thank you, Safari (see issue #106)\n        {\n          var results = Papa.parse(msg.input, msg.config);\n          if (results) global.postMessage({\n            workerId: Papa.WORKER_ID,\n            results: results,\n            finished: true\n          });\n        }\n    }\n    /** Makes a deep copy of an array or object (mostly) */\n\n\n    function copy(obj) {\n      if (typeof obj !== 'object' || obj === null) return obj;\n      var cpy = Array.isArray(obj) ? [] : {};\n\n      for (var key in obj) cpy[key] = copy(obj[key]);\n\n      return cpy;\n    }\n\n    function bindFunction(f, self) {\n      return function () {\n        f.apply(self, arguments);\n      };\n    }\n\n    function isFunction(func) {\n      return typeof func === 'function';\n    }\n\n    return Papa;\n  });\n});\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction getSize(size) {\n  var sizeKb = 1024;\n  var sizeMb = sizeKb * sizeKb;\n  var sizeGb = sizeMb * sizeKb;\n  var sizeTerra = sizeGb * sizeKb;\n\n  if (size < sizeMb) {\n    return (size / sizeKb).toFixed(0) + ' KB';\n  } else if (size < sizeGb) {\n    return (size / sizeMb).toFixed(0) + ' MB';\n  } else if (size < sizeTerra) {\n    return (size / sizeGb).toFixed(0) + ' GB';\n  }\n\n  return '';\n}\n\nvar CSVReaderRewrite =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(CSVReaderRewrite, _Component);\n\n  function CSVReaderRewrite() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, CSVReaderRewrite);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(CSVReaderRewrite)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_this), \"inputFileRef\", React.createRef());\n\n    _defineProperty(_assertThisInitialized(_this), \"dropAreaRef\", React.createRef());\n\n    _defineProperty(_assertThisInitialized(_this), \"fileSizeInfoRef\", React.createRef());\n\n    _defineProperty(_assertThisInitialized(_this), \"fileNameInfoRef\", React.createRef());\n\n    _defineProperty(_assertThisInitialized(_this), \"progressBarFillRef\", React.createRef());\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      dropAreaStyle: styles.dropArea,\n      hasFiles: false,\n      progressBar: 0,\n      displayProgressBarStatus: 'none',\n      file: ''\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"componentDidMount\", function () {\n      var currentDropAreaRef = _this.dropAreaRef.current;\n      var fourDragsEvent = ['dragenter', 'dragover', 'dragleave', 'drop'];\n      fourDragsEvent.forEach(function (item) {\n        currentDropAreaRef.addEventListener(item, _this._preventDefaults, false);\n      });\n\n      if (!_this.props.noDrag) {\n        var highlightDragsEvent = ['dragenter', 'dragover'];\n        highlightDragsEvent.forEach(function (item) {\n          currentDropAreaRef.addEventListener(item, _this._highlight, false);\n        });\n        currentDropAreaRef.addEventListener('dragleave', _this._unhighlight, false);\n        currentDropAreaRef.addEventListener('drop', _this._unhighlight, false);\n        currentDropAreaRef.addEventListener('drop', _this._visibleProgressBar, false);\n        currentDropAreaRef.addEventListener('drop', _this._handleDrop, false);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_preventDefaults\", function (e) {\n      e.preventDefault();\n      e.stopPropagation();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_highlight\", function (e) {\n      _this.setState({\n        dropAreaStyle: Object.assign({}, styles.dropArea, styles.highlight)\n      });\n\n      _this._initializeProgress();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_unhighlight\", function (e) {\n      _this.setState({\n        dropAreaStyle: Object.assign({}, styles.dropArea, styles.unhighlight)\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_visibleProgressBar\", function () {\n      _this.setState({\n        displayProgressBarStatus: 'block'\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_handleDrop\", function (e) {\n      var files = {};\n\n      if (e.files === undefined) {\n        var dt = e.dataTransfer;\n        files = dt.files;\n      } else {\n        files = e.files;\n      }\n\n      _this.setState({\n        hasFiles: true\n      }, function () {\n        _this._handleFiles(files);\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_handleFiles\", function (files) {\n      _this.setState({\n        progressBar: 0\n      });\n\n      files = _toConsumableArray(files);\n      files.forEach(_this._uploadFile);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_updateProgress\", function (percent) {\n      _this.setState({\n        progressBar: percent\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_disableProgressBar\", function () {\n      _this.setState({\n        displayProgressBarStatus: 'none'\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_uploadFile\", function (file, index) {\n      _this._displayFileInfo(file);\n\n      _this.setState({\n        file: file\n      });\n\n      var _this$props = _this.props,\n          onDrop = _this$props.onDrop,\n          onFileLoad = _this$props.onFileLoad,\n          onError = _this$props.onError,\n          _this$props$config = _this$props.config,\n          config = _this$props$config === void 0 ? {} : _this$props$config;\n      var reader = new window.FileReader();\n      var options = {};\n\n      if (config.error) {\n        delete config['error'];\n      }\n\n      if (config.step) {\n        delete config['step'];\n      }\n\n      if (config.complete) {\n        delete config['complete'];\n      }\n\n      var size = file.size;\n      var data = [];\n      var percent = 0;\n\n      if (onDrop || onFileLoad) {\n        var self = _assertThisInitialized(_this);\n\n        options = Object.assign({\n          complete: function complete() {\n            if (!onDrop) {\n              onFileLoad(data);\n            } else {\n              onDrop(data);\n            }\n          },\n          step: function step(row, parser) {\n            data.push(row);\n            var progress = row.meta.cursor;\n            var newPercent = Math.round(progress / size * 100);\n            if (newPercent === percent) return;\n            percent = newPercent;\n\n            self._updateProgress(percent);\n          }\n        }, options);\n      }\n\n      if (onError) {\n        options = Object.assign({\n          error: onError\n        }, options);\n      }\n\n      if (config) {\n        options = Object.assign(config, options);\n      }\n\n      reader.onload = function (e) {\n        papaparse.parse(e.target.result, options);\n      };\n\n      reader.onloadend = function (e) {\n        var timeout = setTimeout(function () {\n          _this._disableProgressBar();\n        }, 2000);\n      };\n\n      reader.readAsText(file, config.encoding || 'utf-8');\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_displayFileInfo\", function (file) {\n      if (!_this._childrenIsFunction()) {\n        _this.fileSizeInfoRef.current.innerHTML = getSize(file.size);\n        _this.fileNameInfoRef.current.innerHTML = file.name;\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_handleInputFileChange\", function (e) {\n      var target = e.target;\n\n      _this.setState({\n        displayProgressBarStatus: 'block'\n      }, function () {\n        _this._handleDrop(target);\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_initializeProgress\", function () {\n      _this.setState({\n        progressBar: 0\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"open\", function (e) {\n      if (e) {\n        e.stopPropagation();\n\n        _this.inputFileRef.current.click();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"renderChildren\", function () {\n      return _this._childrenIsFunction() ? _this.props.children({\n        file: _this.state.file\n      }) : _this.props.children;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_childrenIsFunction\", function () {\n      return typeof _this.props.children === 'function';\n    });\n\n    return _this;\n  }\n\n  _createClass(CSVReaderRewrite, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props2 = this.props,\n          style = _this$props2.style,\n          noClick = _this$props2.noClick,\n          children = _this$props2.children,\n          progressBarColor = _this$props2.progressBarColor;\n      return React.createElement(React.Fragment, null, React.createElement(\"input\", {\n        type: \"file\",\n        accept: \"text/csv\",\n        ref: this.inputFileRef,\n        style: styles.inputFile,\n        onChange: function onChange(e) {\n          return _this2._handleInputFileChange(e);\n        }\n      }), !this._childrenIsFunction() ? React.createElement(\"div\", {\n        ref: this.dropAreaRef,\n        style: Object.assign({}, style, this.state.dropAreaStyle, noClick ? styles.defaultCursor : styles.pointerCursor),\n        onClick: noClick ? function () {} : this.open\n      }, this.state.hasFiles ? React.createElement(\"div\", {\n        style: Object.assign({}, styles.dropFile, styles.column)\n      }, React.createElement(\"div\", {\n        style: styles.column\n      }, React.createElement(\"span\", {\n        style: styles.fileSizeInfo,\n        ref: this.fileSizeInfoRef\n      }), React.createElement(\"span\", {\n        style: styles.fileNameInfo,\n        ref: this.fileNameInfoRef\n      })), React.createElement(\"div\", {\n        style: styles.progressBar\n      }, React.createElement(\"span\", {\n        style: Object.assign({}, styles.progressBarFill, {\n          width: \"\".concat(this.state.progressBar, \"%\"),\n          display: this.state.displayProgressBarStatus\n        }),\n        ref: this.progressBarFillRef\n      }))) : children) : React.createElement(\"div\", {\n        ref: this.dropAreaRef\n      }, this.renderChildren(), React.createElement(\"div\", {\n        style: Object.assign({}, styles.progressBar, {\n          position: 'inherit',\n          width: '100%'\n        })\n      }, React.createElement(\"span\", {\n        style: Object.assign({}, styles.progressBarFill, {\n          backgroundColor: progressBarColor || '#659cef'\n        }, {\n          width: \"\".concat(this.state.progressBar, \"%\"),\n          display: this.state.displayProgressBarStatus\n        }),\n        ref: this.progressBarFillRef\n      }))));\n    }\n  }]);\n\n  return CSVReaderRewrite;\n}(Component);\n\n_defineProperty(CSVReaderRewrite, \"propTypes\", {\n  children: PropTypes.any.isRequired,\n  onDrop: PropTypes.func,\n  onFileLoad: PropTypes.func,\n  onError: PropTypes.func,\n  config: PropTypes.object,\n  style: PropTypes.object,\n  noClick: PropTypes.bool,\n  noDrag: PropTypes.bool,\n  progressBarColor: PropTypes.string\n});\n\nvar styles = {\n  dropArea: {\n    border: '2px dashed #ccc',\n    borderRadius: 20,\n    height: '100%',\n    padding: 20,\n    display: 'flex',\n    justifyContent: 'center',\n    alignItems: 'center',\n    flexDirection: 'column'\n  },\n  inputFile: {\n    display: 'none'\n  },\n  highlight: {\n    borderColor: 'purple'\n  },\n  unhighlight: {\n    borderColor: '#ccc'\n  },\n  dropFile: _defineProperty({\n    borderRadius: 20,\n    background: 'linear-gradient(to bottom, #eee, #ddd)',\n    width: 100,\n    height: 120,\n    position: 'relative',\n    display: 'block',\n    zIndex: 10,\n    paddingLeft: 10,\n    paddingRight: 10\n  }, \"position\", 'relative'),\n  column: {\n    display: 'flex',\n    justifyContent: 'center',\n    alignItems: 'center',\n    flexDirection: 'column'\n  },\n  progressBar: _defineProperty({\n    width: '80%',\n    borderRadius: 3,\n    boxShadow: 'inset 0 1px 3px rgba(0, 0, 0, .2)',\n    bottom: 0,\n    position: 'absolute'\n  }, \"bottom\", 14),\n  progressBarFill: {\n    height: 10,\n    backgroundColor: '#659cef',\n    borderRadius: 3,\n    transition: 'width 500ms ease-in-out'\n  },\n  fileSizeInfo: {\n    backgroundColor: 'rgba(255, 255, 255, 0.4)',\n    padding: '0 0.4em',\n    borderRadius: 3,\n    lineHeight: 1,\n    marginBottom: '0.5em'\n  },\n  fileNameInfo: {\n    fontSize: 14,\n    backgroundColor: 'rgba(255, 255, 255, 0.4)',\n    padding: '0 0.4em',\n    borderRadius: 3,\n    lineHeight: 1\n  },\n  defaultCursor: {\n    cursor: 'default'\n  },\n  pointerCursor: {\n    cursor: 'pointer'\n  }\n};\n\nfunction readString(str) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return papaparse.parse(str, options);\n}\n\nfunction readRemoteFile(url) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  papaparse.parse(url, Object.assign({}, {\n    download: true\n  }, options));\n}\n\nfunction jsonToCSV(json) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return papaparse.unparse(json, options);\n}\n\nvar BAD_DELIMITERS = papaparse.BAD_DELIMITERS;\nvar RECORD_SEP = papaparse.RECORD_SEP;\nvar UNIT_SEP = papaparse.UNIT_SEP;\nvar WORKERS_SUPPORTED = papaparse.WORKERS_SUPPORTED;\nvar LocalChunkSize = papaparse.LocalChunkSize;\nvar DefaultDelimiter = papaparse.DefaultDelimiter;\nexport { BAD_DELIMITERS, CSVReaderRewrite as CSVReader, DefaultDelimiter, LocalChunkSize, RECORD_SEP, UNIT_SEP, WORKERS_SUPPORTED, jsonToCSV, readRemoteFile, readString };","map":{"version":3,"sources":["../node_modules/papaparse/papaparse.js","../src/util.js","../src/CSVReader.js","../src/readString.js","../src/readRemoteFile.js","../src/jsonToCSV.js","../src/index.js"],"names":["this","require$$0","stream","sizeKb","sizeMb","sizeGb","sizeTerra","size","CSVReaderRewrite","Component","React","children","PropTypes","onDrop","onFileLoad","onError","config","style","noClick","noDrag","progressBarColor","string","dropAreaStyle","styles","hasFiles","progressBar","displayProgressBarStatus","file","currentDropAreaRef","fourDragsEvent","highlightDragsEvent","e","Object","files","dt","percent","reader","window","options","data","self","complete","step","progress","row","newPercent","Math","error","PapaParse","timeout","setTimeout","getSize","target","open","column","fileSizeInfoRef","fileNameInfoRef","width","display","progressBarFillRef","dropAreaRef","position","backgroundColor","dropArea","border","borderRadius","height","padding","justifyContent","alignItems","flexDirection","inputFile","highlight","borderColor","unhighlight","dropFile","background","zIndex","paddingLeft","paddingRight","boxShadow","bottom","progressBarFill","transition","fileSizeInfo","lineHeight","marginBottom","fileNameInfo","fontSize","defaultCursor","cursor","pointerCursor","download","BAD_DELIMITERS","RECORD_SEP","UNIT_SEP","WORKERS_SUPPORTED","LocalChunkSize","DefaultDelimiter"],"mappings":"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","sourcesContent":["/* @license\nPapa Parse\nv5.1.1\nhttps://github.com/mholt/PapaParse\nLicense: MIT\n*/\n\n(function(root, factory)\n{\n\t/* globals define */\n\tif (typeof define === 'function' && define.amd)\n\t{\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine([], factory);\n\t}\n\telse if (typeof module === 'object' && typeof exports !== 'undefined')\n\t{\n\t\t// Node. Does not work with strict CommonJS, but\n\t\t// only CommonJS-like environments that support module.exports,\n\t\t// like Node.\n\t\tmodule.exports = factory();\n\t}\n\telse\n\t{\n\t\t// Browser globals (root is window)\n\t\troot.Papa = factory();\n\t}\n\t// in strict mode we cannot access arguments.callee, so we need a named reference to\n\t// stringify the factory method for the blob worker\n\t// eslint-disable-next-line func-name\n}(this, function moduleFactory()\n{\n\t'use strict';\n\n\tvar global = (function() {\n\t\t// alternative method, similar to `Function('return this')()`\n\t\t// but without using `eval` (which is disabled when\n\t\t// using Content Security Policy).\n\n\t\tif (typeof self !== 'undefined') { return self; }\n\t\tif (typeof window !== 'undefined') { return window; }\n\t\tif (typeof global !== 'undefined') { return global; }\n\n\t\t// When running tests none of the above have been defined\n\t\treturn {};\n\t})();\n\n\n\tfunction getWorkerBlob() {\n\t\tvar URL = global.URL || global.webkitURL || null;\n\t\tvar code = moduleFactory.toString();\n\t\treturn Papa.BLOB_URL || (Papa.BLOB_URL = URL.createObjectURL(new Blob(['(', code, ')();'], {type: 'text/javascript'})));\n\t}\n\n\tvar IS_WORKER = !global.document && !!global.postMessage,\n\t\tIS_PAPA_WORKER = IS_WORKER && /blob:/i.test((global.location || {}).protocol);\n\tvar workers = {}, workerIdCounter = 0;\n\n\tvar Papa = {};\n\n\tPapa.parse = CsvToJson;\n\tPapa.unparse = JsonToCsv;\n\n\tPapa.RECORD_SEP = String.fromCharCode(30);\n\tPapa.UNIT_SEP = String.fromCharCode(31);\n\tPapa.BYTE_ORDER_MARK = '\\ufeff';\n\tPapa.BAD_DELIMITERS = ['\\r', '\\n', '\"', Papa.BYTE_ORDER_MARK];\n\tPapa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker;\n\tPapa.NODE_STREAM_INPUT = 1;\n\n\t// Configurable chunk sizes for local and remote files, respectively\n\tPapa.LocalChunkSize = 1024 * 1024 * 10;\t// 10 MB\n\tPapa.RemoteChunkSize = 1024 * 1024 * 5;\t// 5 MB\n\tPapa.DefaultDelimiter = ',';\t\t\t// Used if not specified and detection fails\n\n\t// Exposed for testing and development only\n\tPapa.Parser = Parser;\n\tPapa.ParserHandle = ParserHandle;\n\tPapa.NetworkStreamer = NetworkStreamer;\n\tPapa.FileStreamer = FileStreamer;\n\tPapa.StringStreamer = StringStreamer;\n\tPapa.ReadableStreamStreamer = ReadableStreamStreamer;\n\tif (typeof PAPA_BROWSER_CONTEXT === 'undefined') {\n\t\tPapa.DuplexStreamStreamer = DuplexStreamStreamer;\n\t}\n\n\tif (global.jQuery)\n\t{\n\t\tvar $ = global.jQuery;\n\t\t$.fn.parse = function(options)\n\t\t{\n\t\t\tvar config = options.config || {};\n\t\t\tvar queue = [];\n\n\t\t\tthis.each(function(idx)\n\t\t\t{\n\t\t\t\tvar supported = $(this).prop('tagName').toUpperCase() === 'INPUT'\n\t\t\t\t\t\t\t\t&& $(this).attr('type').toLowerCase() === 'file'\n\t\t\t\t\t\t\t\t&& global.FileReader;\n\n\t\t\t\tif (!supported || !this.files || this.files.length === 0)\n\t\t\t\t\treturn true;\t// continue to next input element\n\n\t\t\t\tfor (var i = 0; i < this.files.length; i++)\n\t\t\t\t{\n\t\t\t\t\tqueue.push({\n\t\t\t\t\t\tfile: this.files[i],\n\t\t\t\t\t\tinputElem: this,\n\t\t\t\t\t\tinstanceConfig: $.extend({}, config)\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tparseNextFile();\t// begin parsing\n\t\t\treturn this;\t\t// maintains chainability\n\n\n\t\t\tfunction parseNextFile()\n\t\t\t{\n\t\t\t\tif (queue.length === 0)\n\t\t\t\t{\n\t\t\t\t\tif (isFunction(options.complete))\n\t\t\t\t\t\toptions.complete();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar f = queue[0];\n\n\t\t\t\tif (isFunction(options.before))\n\t\t\t\t{\n\t\t\t\t\tvar returned = options.before(f.file, f.inputElem);\n\n\t\t\t\t\tif (typeof returned === 'object')\n\t\t\t\t\t{\n\t\t\t\t\t\tif (returned.action === 'abort')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror('AbortError', f.file, f.inputElem, returned.reason);\n\t\t\t\t\t\t\treturn;\t// Aborts all queued files immediately\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (returned.action === 'skip')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfileComplete();\t// parse the next file in the queue, if any\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (typeof returned.config === 'object')\n\t\t\t\t\t\t\tf.instanceConfig = $.extend(f.instanceConfig, returned.config);\n\t\t\t\t\t}\n\t\t\t\t\telse if (returned === 'skip')\n\t\t\t\t\t{\n\t\t\t\t\t\tfileComplete();\t// parse the next file in the queue, if any\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Wrap up the user's complete callback, if any, so that ours also gets executed\n\t\t\t\tvar userCompleteFunc = f.instanceConfig.complete;\n\t\t\t\tf.instanceConfig.complete = function(results)\n\t\t\t\t{\n\t\t\t\t\tif (isFunction(userCompleteFunc))\n\t\t\t\t\t\tuserCompleteFunc(results, f.file, f.inputElem);\n\t\t\t\t\tfileComplete();\n\t\t\t\t};\n\n\t\t\t\tPapa.parse(f.file, f.instanceConfig);\n\t\t\t}\n\n\t\t\tfunction error(name, file, elem, reason)\n\t\t\t{\n\t\t\t\tif (isFunction(options.error))\n\t\t\t\t\toptions.error({name: name}, file, elem, reason);\n\t\t\t}\n\n\t\t\tfunction fileComplete()\n\t\t\t{\n\t\t\t\tqueue.splice(0, 1);\n\t\t\t\tparseNextFile();\n\t\t\t}\n\t\t};\n\t}\n\n\n\tif (IS_PAPA_WORKER)\n\t{\n\t\tglobal.onmessage = workerThreadReceivedMessage;\n\t}\n\n\n\n\n\tfunction CsvToJson(_input, _config)\n\t{\n\t\t_config = _config || {};\n\t\tvar dynamicTyping = _config.dynamicTyping || false;\n\t\tif (isFunction(dynamicTyping)) {\n\t\t\t_config.dynamicTypingFunction = dynamicTyping;\n\t\t\t// Will be filled on first row call\n\t\t\tdynamicTyping = {};\n\t\t}\n\t\t_config.dynamicTyping = dynamicTyping;\n\n\t\t_config.transform = isFunction(_config.transform) ? _config.transform : false;\n\n\t\tif (_config.worker && Papa.WORKERS_SUPPORTED)\n\t\t{\n\t\t\tvar w = newWorker();\n\n\t\t\tw.userStep = _config.step;\n\t\t\tw.userChunk = _config.chunk;\n\t\t\tw.userComplete = _config.complete;\n\t\t\tw.userError = _config.error;\n\n\t\t\t_config.step = isFunction(_config.step);\n\t\t\t_config.chunk = isFunction(_config.chunk);\n\t\t\t_config.complete = isFunction(_config.complete);\n\t\t\t_config.error = isFunction(_config.error);\n\t\t\tdelete _config.worker;\t// prevent infinite loop\n\n\t\t\tw.postMessage({\n\t\t\t\tinput: _input,\n\t\t\t\tconfig: _config,\n\t\t\t\tworkerId: w.id\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\tvar streamer = null;\n\t\tif (_input === Papa.NODE_STREAM_INPUT && typeof PAPA_BROWSER_CONTEXT === 'undefined')\n\t\t{\n\t\t\t// create a node Duplex stream for use\n\t\t\t// with .pipe\n\t\t\tstreamer = new DuplexStreamStreamer(_config);\n\t\t\treturn streamer.getStream();\n\t\t}\n\t\telse if (typeof _input === 'string')\n\t\t{\n\t\t\tif (_config.download)\n\t\t\t\tstreamer = new NetworkStreamer(_config);\n\t\t\telse\n\t\t\t\tstreamer = new StringStreamer(_config);\n\t\t}\n\t\telse if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on))\n\t\t{\n\t\t\tstreamer = new ReadableStreamStreamer(_config);\n\t\t}\n\t\telse if ((global.File && _input instanceof File) || _input instanceof Object)\t// ...Safari. (see issue #106)\n\t\t\tstreamer = new FileStreamer(_config);\n\n\t\treturn streamer.stream(_input);\n\t}\n\n\n\n\n\n\n\tfunction JsonToCsv(_input, _config)\n\t{\n\t\t// Default configuration\n\n\t\t/** whether to surround every datum with quotes */\n\t\tvar _quotes = false;\n\n\t\t/** whether to write headers */\n\t\tvar _writeHeader = true;\n\n\t\t/** delimiting character(s) */\n\t\tvar _delimiter = ',';\n\n\t\t/** newline character(s) */\n\t\tvar _newline = '\\r\\n';\n\n\t\t/** quote character */\n\t\tvar _quoteChar = '\"';\n\n\t\t/** escaped quote character, either \"\" or <config.escapeChar>\" */\n\t\tvar _escapedQuote = _quoteChar + _quoteChar;\n\n\t\t/** whether to skip empty lines */\n\t\tvar _skipEmptyLines = false;\n\n\t\t/** the columns (keys) we expect when we unparse objects */\n\t\tvar _columns = null;\n\n\t\tunpackConfig();\n\n\t\tvar quoteCharRegex = new RegExp(escapeRegExp(_quoteChar), 'g');\n\n\t\tif (typeof _input === 'string')\n\t\t\t_input = JSON.parse(_input);\n\n\t\tif (Array.isArray(_input))\n\t\t{\n\t\t\tif (!_input.length || Array.isArray(_input[0]))\n\t\t\t\treturn serialize(null, _input, _skipEmptyLines);\n\t\t\telse if (typeof _input[0] === 'object')\n\t\t\t\treturn serialize(_columns || objectKeys(_input[0]), _input, _skipEmptyLines);\n\t\t}\n\t\telse if (typeof _input === 'object')\n\t\t{\n\t\t\tif (typeof _input.data === 'string')\n\t\t\t\t_input.data = JSON.parse(_input.data);\n\n\t\t\tif (Array.isArray(_input.data))\n\t\t\t{\n\t\t\t\tif (!_input.fields)\n\t\t\t\t\t_input.fields =  _input.meta && _input.meta.fields;\n\n\t\t\t\tif (!_input.fields)\n\t\t\t\t\t_input.fields =  Array.isArray(_input.data[0])\n\t\t\t\t\t\t? _input.fields\n\t\t\t\t\t\t: objectKeys(_input.data[0]);\n\n\t\t\t\tif (!(Array.isArray(_input.data[0])) && typeof _input.data[0] !== 'object')\n\t\t\t\t\t_input.data = [_input.data];\t// handles input like [1,2,3] or ['asdf']\n\t\t\t}\n\n\t\t\treturn serialize(_input.fields || [], _input.data || [], _skipEmptyLines);\n\t\t}\n\n\t\t// Default (any valid paths should return before this)\n\t\tthrow new Error('Unable to serialize unrecognized input');\n\n\n\t\tfunction unpackConfig()\n\t\t{\n\t\t\tif (typeof _config !== 'object')\n\t\t\t\treturn;\n\n\t\t\tif (typeof _config.delimiter === 'string'\n                && !Papa.BAD_DELIMITERS.filter(function(value) { return _config.delimiter.indexOf(value) !== -1; }).length)\n\t\t\t{\n\t\t\t\t_delimiter = _config.delimiter;\n\t\t\t}\n\n\t\t\tif (typeof _config.quotes === 'boolean'\n\t\t\t\t|| typeof _config.quotes === 'function'\n\t\t\t\t|| Array.isArray(_config.quotes))\n\t\t\t\t_quotes = _config.quotes;\n\n\t\t\tif (typeof _config.skipEmptyLines === 'boolean'\n\t\t\t\t|| typeof _config.skipEmptyLines === 'string')\n\t\t\t\t_skipEmptyLines = _config.skipEmptyLines;\n\n\t\t\tif (typeof _config.newline === 'string')\n\t\t\t\t_newline = _config.newline;\n\n\t\t\tif (typeof _config.quoteChar === 'string')\n\t\t\t\t_quoteChar = _config.quoteChar;\n\n\t\t\tif (typeof _config.header === 'boolean')\n\t\t\t\t_writeHeader = _config.header;\n\n\t\t\tif (Array.isArray(_config.columns)) {\n\n\t\t\t\tif (_config.columns.length === 0) throw new Error('Option columns is empty');\n\n\t\t\t\t_columns = _config.columns;\n\t\t\t}\n\n\t\t\tif (_config.escapeChar !== undefined) {\n\t\t\t\t_escapedQuote = _config.escapeChar + _quoteChar;\n\t\t\t}\n\t\t}\n\n\n\t\t/** Turns an object's keys into an array */\n\t\tfunction objectKeys(obj)\n\t\t{\n\t\t\tif (typeof obj !== 'object')\n\t\t\t\treturn [];\n\t\t\tvar keys = [];\n\t\t\tfor (var key in obj)\n\t\t\t\tkeys.push(key);\n\t\t\treturn keys;\n\t\t}\n\n\t\t/** The double for loop that iterates the data and writes out a CSV string including header row */\n\t\tfunction serialize(fields, data, skipEmptyLines)\n\t\t{\n\t\t\tvar csv = '';\n\n\t\t\tif (typeof fields === 'string')\n\t\t\t\tfields = JSON.parse(fields);\n\t\t\tif (typeof data === 'string')\n\t\t\t\tdata = JSON.parse(data);\n\n\t\t\tvar hasHeader = Array.isArray(fields) && fields.length > 0;\n\t\t\tvar dataKeyedByField = !(Array.isArray(data[0]));\n\n\t\t\t// If there a header row, write it first\n\t\t\tif (hasHeader && _writeHeader)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < fields.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (i > 0)\n\t\t\t\t\t\tcsv += _delimiter;\n\t\t\t\t\tcsv += safe(fields[i], i);\n\t\t\t\t}\n\t\t\t\tif (data.length > 0)\n\t\t\t\t\tcsv += _newline;\n\t\t\t}\n\n\t\t\t// Then write out the data\n\t\t\tfor (var row = 0; row < data.length; row++)\n\t\t\t{\n\t\t\t\tvar maxCol = hasHeader ? fields.length : data[row].length;\n\n\t\t\t\tvar emptyLine = false;\n\t\t\t\tvar nullLine = hasHeader ? Object.keys(data[row]).length === 0 : data[row].length === 0;\n\t\t\t\tif (skipEmptyLines && !hasHeader)\n\t\t\t\t{\n\t\t\t\t\temptyLine = skipEmptyLines === 'greedy' ? data[row].join('').trim() === '' : data[row].length === 1 && data[row][0].length === 0;\n\t\t\t\t}\n\t\t\t\tif (skipEmptyLines === 'greedy' && hasHeader) {\n\t\t\t\t\tvar line = [];\n\t\t\t\t\tfor (var c = 0; c < maxCol; c++) {\n\t\t\t\t\t\tvar cx = dataKeyedByField ? fields[c] : c;\n\t\t\t\t\t\tline.push(data[row][cx]);\n\t\t\t\t\t}\n\t\t\t\t\temptyLine = line.join('').trim() === '';\n\t\t\t\t}\n\t\t\t\tif (!emptyLine)\n\t\t\t\t{\n\t\t\t\t\tfor (var col = 0; col < maxCol; col++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (col > 0 && !nullLine)\n\t\t\t\t\t\t\tcsv += _delimiter;\n\t\t\t\t\t\tvar colIdx = hasHeader && dataKeyedByField ? fields[col] : col;\n\t\t\t\t\t\tcsv += safe(data[row][colIdx], col);\n\t\t\t\t\t}\n\t\t\t\t\tif (row < data.length - 1 && (!skipEmptyLines || (maxCol > 0 && !nullLine)))\n\t\t\t\t\t{\n\t\t\t\t\t\tcsv += _newline;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn csv;\n\t\t}\n\n\t\t/** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */\n\t\tfunction safe(str, col)\n\t\t{\n\t\t\tif (typeof str === 'undefined' || str === null)\n\t\t\t\treturn '';\n\n\t\t\tif (str.constructor === Date)\n\t\t\t\treturn JSON.stringify(str).slice(1, 25);\n\n\t\t\tvar escapedQuoteStr = str.toString().replace(quoteCharRegex, _escapedQuote);\n\n\t\t\tvar needsQuotes = (typeof _quotes === 'boolean' && _quotes)\n\t\t\t\t\t\t\t|| (typeof _quotes === 'function' && _quotes(str, col))\n\t\t\t\t\t\t\t|| (Array.isArray(_quotes) && _quotes[col])\n\t\t\t\t\t\t\t|| hasAny(escapedQuoteStr, Papa.BAD_DELIMITERS)\n\t\t\t\t\t\t\t|| escapedQuoteStr.indexOf(_delimiter) > -1\n\t\t\t\t\t\t\t|| escapedQuoteStr.charAt(0) === ' '\n\t\t\t\t\t\t\t|| escapedQuoteStr.charAt(escapedQuoteStr.length - 1) === ' ';\n\n\t\t\treturn needsQuotes ? _quoteChar + escapedQuoteStr + _quoteChar : escapedQuoteStr;\n\t\t}\n\n\t\tfunction hasAny(str, substrings)\n\t\t{\n\t\t\tfor (var i = 0; i < substrings.length; i++)\n\t\t\t\tif (str.indexOf(substrings[i]) > -1)\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/** ChunkStreamer is the base prototype for various streamer implementations. */\n\tfunction ChunkStreamer(config)\n\t{\n\t\tthis._handle = null;\n\t\tthis._finished = false;\n\t\tthis._completed = false;\n\t\tthis._halted = false;\n\t\tthis._input = null;\n\t\tthis._baseIndex = 0;\n\t\tthis._partialLine = '';\n\t\tthis._rowCount = 0;\n\t\tthis._start = 0;\n\t\tthis._nextChunk = null;\n\t\tthis.isFirstChunk = true;\n\t\tthis._completeResults = {\n\t\t\tdata: [],\n\t\t\terrors: [],\n\t\t\tmeta: {}\n\t\t};\n\t\treplaceConfig.call(this, config);\n\n\t\tthis.parseChunk = function(chunk, isFakeChunk)\n\t\t{\n\t\t\t// First chunk pre-processing\n\t\t\tif (this.isFirstChunk && isFunction(this._config.beforeFirstChunk))\n\t\t\t{\n\t\t\t\tvar modifiedChunk = this._config.beforeFirstChunk(chunk);\n\t\t\t\tif (modifiedChunk !== undefined)\n\t\t\t\t\tchunk = modifiedChunk;\n\t\t\t}\n\t\t\tthis.isFirstChunk = false;\n\t\t\tthis._halted = false;\n\n\t\t\t// Rejoin the line we likely just split in two by chunking the file\n\t\t\tvar aggregate = this._partialLine + chunk;\n\t\t\tthis._partialLine = '';\n\n\t\t\tvar results = this._handle.parse(aggregate, this._baseIndex, !this._finished);\n\n\t\t\tif (this._handle.paused() || this._handle.aborted()) {\n\t\t\t\tthis._halted = true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar lastIndex = results.meta.cursor;\n\n\t\t\tif (!this._finished)\n\t\t\t{\n\t\t\t\tthis._partialLine = aggregate.substring(lastIndex - this._baseIndex);\n\t\t\t\tthis._baseIndex = lastIndex;\n\t\t\t}\n\n\t\t\tif (results && results.data)\n\t\t\t\tthis._rowCount += results.data.length;\n\n\t\t\tvar finishedIncludingPreview = this._finished || (this._config.preview && this._rowCount >= this._config.preview);\n\n\t\t\tif (IS_PAPA_WORKER)\n\t\t\t{\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tresults: results,\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\tfinished: finishedIncludingPreview\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if (isFunction(this._config.chunk) && !isFakeChunk)\n\t\t\t{\n\t\t\t\tthis._config.chunk(results, this._handle);\n\t\t\t\tif (this._handle.paused() || this._handle.aborted()) {\n\t\t\t\t\tthis._halted = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresults = undefined;\n\t\t\t\tthis._completeResults = undefined;\n\t\t\t}\n\n\t\t\tif (!this._config.step && !this._config.chunk) {\n\t\t\t\tthis._completeResults.data = this._completeResults.data.concat(results.data);\n\t\t\t\tthis._completeResults.errors = this._completeResults.errors.concat(results.errors);\n\t\t\t\tthis._completeResults.meta = results.meta;\n\t\t\t}\n\n\t\t\tif (!this._completed && finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted)) {\n\t\t\t\tthis._config.complete(this._completeResults, this._input);\n\t\t\t\tthis._completed = true;\n\t\t\t}\n\n\t\t\tif (!finishedIncludingPreview && (!results || !results.meta.paused))\n\t\t\t\tthis._nextChunk();\n\n\t\t\treturn results;\n\t\t};\n\n\t\tthis._sendError = function(error)\n\t\t{\n\t\t\tif (isFunction(this._config.error))\n\t\t\t\tthis._config.error(error);\n\t\t\telse if (IS_PAPA_WORKER && this._config.error)\n\t\t\t{\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\terror: error,\n\t\t\t\t\tfinished: false\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tfunction replaceConfig(config)\n\t\t{\n\t\t\t// Deep-copy the config so we can edit it\n\t\t\tvar configCopy = copy(config);\n\t\t\tconfigCopy.chunkSize = parseInt(configCopy.chunkSize);\t// parseInt VERY important so we don't concatenate strings!\n\t\t\tif (!config.step && !config.chunk)\n\t\t\t\tconfigCopy.chunkSize = null;  // disable Range header if not streaming; bad values break IIS - see issue #196\n\t\t\tthis._handle = new ParserHandle(configCopy);\n\t\t\tthis._handle.streamer = this;\n\t\t\tthis._config = configCopy;\t// persist the copy to the caller\n\t\t}\n\t}\n\n\n\tfunction NetworkStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tif (!config.chunkSize)\n\t\t\tconfig.chunkSize = Papa.RemoteChunkSize;\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar xhr;\n\n\t\tif (IS_WORKER)\n\t\t{\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tthis._readChunk();\n\t\t\t\tthis._chunkLoaded();\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tthis._readChunk();\n\t\t\t};\n\t\t}\n\n\t\tthis.stream = function(url)\n\t\t{\n\t\t\tthis._input = url;\n\t\t\tthis._nextChunk();\t// Starts streaming\n\t\t};\n\n\t\tthis._readChunk = function()\n\t\t{\n\t\t\tif (this._finished)\n\t\t\t{\n\t\t\t\tthis._chunkLoaded();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\txhr = new XMLHttpRequest();\n\n\t\t\tif (this._config.withCredentials)\n\t\t\t{\n\t\t\t\txhr.withCredentials = this._config.withCredentials;\n\t\t\t}\n\n\t\t\tif (!IS_WORKER)\n\t\t\t{\n\t\t\t\txhr.onload = bindFunction(this._chunkLoaded, this);\n\t\t\t\txhr.onerror = bindFunction(this._chunkError, this);\n\t\t\t}\n\n\t\t\txhr.open('GET', this._input, !IS_WORKER);\n\t\t\t// Headers can only be set when once the request state is OPENED\n\t\t\tif (this._config.downloadRequestHeaders)\n\t\t\t{\n\t\t\t\tvar headers = this._config.downloadRequestHeaders;\n\n\t\t\t\tfor (var headerName in headers)\n\t\t\t\t{\n\t\t\t\t\txhr.setRequestHeader(headerName, headers[headerName]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this._config.chunkSize)\n\t\t\t{\n\t\t\t\tvar end = this._start + this._config.chunkSize - 1;\t// minus one because byte range is inclusive\n\t\t\t\txhr.setRequestHeader('Range', 'bytes=' + this._start + '-' + end);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\txhr.send();\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\tthis._chunkError(err.message);\n\t\t\t}\n\n\t\t\tif (IS_WORKER && xhr.status === 0)\n\t\t\t\tthis._chunkError();\n\t\t};\n\n\t\tthis._chunkLoaded = function()\n\t\t{\n\t\t\tif (xhr.readyState !== 4)\n\t\t\t\treturn;\n\n\t\t\tif (xhr.status < 200 || xhr.status >= 400)\n\t\t\t{\n\t\t\t\tthis._chunkError();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Use chunckSize as it may be a diference on reponse lentgh due to characters with more than 1 byte\n\t\t\tthis._start += this._config.chunkSize ? this._config.chunkSize : xhr.responseText.length;\n\t\t\tthis._finished = !this._config.chunkSize || this._start >= getFileSize(xhr);\n\t\t\tthis.parseChunk(xhr.responseText);\n\t\t};\n\n\t\tthis._chunkError = function(errorMessage)\n\t\t{\n\t\t\tvar errorText = xhr.statusText || errorMessage;\n\t\t\tthis._sendError(new Error(errorText));\n\t\t};\n\n\t\tfunction getFileSize(xhr)\n\t\t{\n\t\t\tvar contentRange = xhr.getResponseHeader('Content-Range');\n\t\t\tif (contentRange === null) { // no content range, then finish!\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn parseInt(contentRange.substring(contentRange.lastIndexOf('/') + 1));\n\t\t}\n\t}\n\tNetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\tNetworkStreamer.prototype.constructor = NetworkStreamer;\n\n\n\tfunction FileStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tif (!config.chunkSize)\n\t\t\tconfig.chunkSize = Papa.LocalChunkSize;\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar reader, slice;\n\n\t\t// FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862\n\t\t// But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76\n\t\tvar usingAsyncReader = typeof FileReader !== 'undefined';\t// Safari doesn't consider it a function - see issue #105\n\n\t\tthis.stream = function(file)\n\t\t{\n\t\t\tthis._input = file;\n\t\t\tslice = file.slice || file.webkitSlice || file.mozSlice;\n\n\t\t\tif (usingAsyncReader)\n\t\t\t{\n\t\t\t\treader = new FileReader();\t\t// Preferred method of reading files, even in workers\n\t\t\t\treader.onload = bindFunction(this._chunkLoaded, this);\n\t\t\t\treader.onerror = bindFunction(this._chunkError, this);\n\t\t\t}\n\t\t\telse\n\t\t\t\treader = new FileReaderSync();\t// Hack for running in a web worker in Firefox\n\n\t\t\tthis._nextChunk();\t// Starts streaming\n\t\t};\n\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tif (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))\n\t\t\t\tthis._readChunk();\n\t\t};\n\n\t\tthis._readChunk = function()\n\t\t{\n\t\t\tvar input = this._input;\n\t\t\tif (this._config.chunkSize)\n\t\t\t{\n\t\t\t\tvar end = Math.min(this._start + this._config.chunkSize, this._input.size);\n\t\t\t\tinput = slice.call(input, this._start, end);\n\t\t\t}\n\t\t\tvar txt = reader.readAsText(input, this._config.encoding);\n\t\t\tif (!usingAsyncReader)\n\t\t\t\tthis._chunkLoaded({ target: { result: txt } });\t// mimic the async signature\n\t\t};\n\n\t\tthis._chunkLoaded = function(event)\n\t\t{\n\t\t\t// Very important to increment start each time before handling results\n\t\t\tthis._start += this._config.chunkSize;\n\t\t\tthis._finished = !this._config.chunkSize || this._start >= this._input.size;\n\t\t\tthis.parseChunk(event.target.result);\n\t\t};\n\n\t\tthis._chunkError = function()\n\t\t{\n\t\t\tthis._sendError(reader.error);\n\t\t};\n\n\t}\n\tFileStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\tFileStreamer.prototype.constructor = FileStreamer;\n\n\n\tfunction StringStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar remaining;\n\t\tthis.stream = function(s)\n\t\t{\n\t\t\tremaining = s;\n\t\t\treturn this._nextChunk();\n\t\t};\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tif (this._finished) return;\n\t\t\tvar size = this._config.chunkSize;\n\t\t\tvar chunk;\n\t\t\tif(size) {\n\t\t\t\tchunk = remaining.substring(0, size);\n\t\t\t\tremaining = remaining.substring(size);\n\t\t\t} else {\n\t\t\t\tchunk = remaining;\n\t\t\t\tremaining = '';\n\t\t\t}\n\t\t\tthis._finished = !remaining;\n\t\t\treturn this.parseChunk(chunk);\n\t\t};\n\t}\n\tStringStreamer.prototype = Object.create(StringStreamer.prototype);\n\tStringStreamer.prototype.constructor = StringStreamer;\n\n\n\tfunction ReadableStreamStreamer(config)\n\t{\n\t\tconfig = config || {};\n\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar queue = [];\n\t\tvar parseOnData = true;\n\t\tvar streamHasEnded = false;\n\n\t\tthis.pause = function()\n\t\t{\n\t\t\tChunkStreamer.prototype.pause.apply(this, arguments);\n\t\t\tthis._input.pause();\n\t\t};\n\n\t\tthis.resume = function()\n\t\t{\n\t\t\tChunkStreamer.prototype.resume.apply(this, arguments);\n\t\t\tthis._input.resume();\n\t\t};\n\n\t\tthis.stream = function(stream)\n\t\t{\n\t\t\tthis._input = stream;\n\n\t\t\tthis._input.on('data', this._streamData);\n\t\t\tthis._input.on('end', this._streamEnd);\n\t\t\tthis._input.on('error', this._streamError);\n\t\t};\n\n\t\tthis._checkIsFinished = function()\n\t\t{\n\t\t\tif (streamHasEnded && queue.length === 1) {\n\t\t\t\tthis._finished = true;\n\t\t\t}\n\t\t};\n\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tthis._checkIsFinished();\n\t\t\tif (queue.length)\n\t\t\t{\n\t\t\t\tthis.parseChunk(queue.shift());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tparseOnData = true;\n\t\t\t}\n\t\t};\n\n\t\tthis._streamData = bindFunction(function(chunk)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tqueue.push(typeof chunk === 'string' ? chunk : chunk.toString(this._config.encoding));\n\n\t\t\t\tif (parseOnData)\n\t\t\t\t{\n\t\t\t\t\tparseOnData = false;\n\t\t\t\t\tthis._checkIsFinished();\n\t\t\t\t\tthis.parseChunk(queue.shift());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (error)\n\t\t\t{\n\t\t\t\tthis._streamError(error);\n\t\t\t}\n\t\t}, this);\n\n\t\tthis._streamError = bindFunction(function(error)\n\t\t{\n\t\t\tthis._streamCleanUp();\n\t\t\tthis._sendError(error);\n\t\t}, this);\n\n\t\tthis._streamEnd = bindFunction(function()\n\t\t{\n\t\t\tthis._streamCleanUp();\n\t\t\tstreamHasEnded = true;\n\t\t\tthis._streamData('');\n\t\t}, this);\n\n\t\tthis._streamCleanUp = bindFunction(function()\n\t\t{\n\t\t\tthis._input.removeListener('data', this._streamData);\n\t\t\tthis._input.removeListener('end', this._streamEnd);\n\t\t\tthis._input.removeListener('error', this._streamError);\n\t\t}, this);\n\t}\n\tReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\tReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;\n\n\n\tfunction DuplexStreamStreamer(_config) {\n\t\tvar Duplex = require('stream').Duplex;\n\t\tvar config = copy(_config);\n\t\tvar parseOnWrite = true;\n\t\tvar writeStreamHasFinished = false;\n\t\tvar parseCallbackQueue = [];\n\t\tvar stream = null;\n\n\t\tthis._onCsvData = function(results)\n\t\t{\n\t\t\tvar data = results.data;\n\t\t\tif (!stream.push(data) && !this._handle.paused()) {\n\t\t\t\t// the writeable consumer buffer has filled up\n\t\t\t\t// so we need to pause until more items\n\t\t\t\t// can be processed\n\t\t\t\tthis._handle.pause();\n\t\t\t}\n\t\t};\n\n\t\tthis._onCsvComplete = function()\n\t\t{\n\t\t\t// node will finish the read stream when\n\t\t\t// null is pushed\n\t\t\tstream.push(null);\n\t\t};\n\n\t\tconfig.step = bindFunction(this._onCsvData, this);\n\t\tconfig.complete = bindFunction(this._onCsvComplete, this);\n\t\tChunkStreamer.call(this, config);\n\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tif (writeStreamHasFinished && parseCallbackQueue.length === 1) {\n\t\t\t\tthis._finished = true;\n\t\t\t}\n\t\t\tif (parseCallbackQueue.length) {\n\t\t\t\tparseCallbackQueue.shift()();\n\t\t\t} else {\n\t\t\t\tparseOnWrite = true;\n\t\t\t}\n\t\t};\n\n\t\tthis._addToParseQueue = function(chunk, callback)\n\t\t{\n\t\t\t// add to queue so that we can indicate\n\t\t\t// completion via callback\n\t\t\t// node will automatically pause the incoming stream\n\t\t\t// when too many items have been added without their\n\t\t\t// callback being invoked\n\t\t\tparseCallbackQueue.push(bindFunction(function() {\n\t\t\t\tthis.parseChunk(typeof chunk === 'string' ? chunk : chunk.toString(config.encoding));\n\t\t\t\tif (isFunction(callback)) {\n\t\t\t\t\treturn callback();\n\t\t\t\t}\n\t\t\t}, this));\n\t\t\tif (parseOnWrite) {\n\t\t\t\tparseOnWrite = false;\n\t\t\t\tthis._nextChunk();\n\t\t\t}\n\t\t};\n\n\t\tthis._onRead = function()\n\t\t{\n\t\t\tif (this._handle.paused()) {\n\t\t\t\t// the writeable consumer can handle more data\n\t\t\t\t// so resume the chunk parsing\n\t\t\t\tthis._handle.resume();\n\t\t\t}\n\t\t};\n\n\t\tthis._onWrite = function(chunk, encoding, callback)\n\t\t{\n\t\t\tthis._addToParseQueue(chunk, callback);\n\t\t};\n\n\t\tthis._onWriteComplete = function()\n\t\t{\n\t\t\twriteStreamHasFinished = true;\n\t\t\t// have to write empty string\n\t\t\t// so parser knows its done\n\t\t\tthis._addToParseQueue('');\n\t\t};\n\n\t\tthis.getStream = function()\n\t\t{\n\t\t\treturn stream;\n\t\t};\n\t\tstream = new Duplex({\n\t\t\treadableObjectMode: true,\n\t\t\tdecodeStrings: false,\n\t\t\tread: bindFunction(this._onRead, this),\n\t\t\twrite: bindFunction(this._onWrite, this)\n\t\t});\n\t\tstream.once('finish', bindFunction(this._onWriteComplete, this));\n\t}\n\tif (typeof PAPA_BROWSER_CONTEXT === 'undefined') {\n\t\tDuplexStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\t\tDuplexStreamStreamer.prototype.constructor = DuplexStreamStreamer;\n\t}\n\n\n\t// Use one ParserHandle per entire CSV file or string\n\tfunction ParserHandle(_config)\n\t{\n\t\t// One goal is to minimize the use of regular expressions...\n\t\tvar MAX_FLOAT = Math.pow(2, 53);\n\t\tvar MIN_FLOAT = -MAX_FLOAT;\n\t\tvar FLOAT = /^\\s*-?(\\d*\\.?\\d+|\\d+\\.?\\d*)(e[-+]?\\d+)?\\s*$/i;\n\t\tvar ISO_DATE = /(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/;\n\t\tvar self = this;\n\t\tvar _stepCounter = 0;\t// Number of times step was called (number of rows parsed)\n\t\tvar _rowCounter = 0;\t// Number of rows that have been parsed so far\n\t\tvar _input;\t\t\t\t// The input being parsed\n\t\tvar _parser;\t\t\t// The core parser being used\n\t\tvar _paused = false;\t// Whether we are paused or not\n\t\tvar _aborted = false;\t// Whether the parser has aborted or not\n\t\tvar _delimiterError;\t// Temporary state between delimiter detection and processing results\n\t\tvar _fields = [];\t\t// Fields are from the header row of the input, if there is one\n\t\tvar _results = {\t\t// The last results returned from the parser\n\t\t\tdata: [],\n\t\t\terrors: [],\n\t\t\tmeta: {}\n\t\t};\n\n\t\tif (isFunction(_config.step))\n\t\t{\n\t\t\tvar userStep = _config.step;\n\t\t\t_config.step = function(results)\n\t\t\t{\n\t\t\t\t_results = results;\n\n\t\t\t\tif (needsHeaderRow())\n\t\t\t\t\tprocessResults();\n\t\t\t\telse\t// only call user's step function after header row\n\t\t\t\t{\n\t\t\t\t\tprocessResults();\n\n\t\t\t\t\t// It's possbile that this line was empty and there's no row here after all\n\t\t\t\t\tif (_results.data.length === 0)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t_stepCounter += results.data.length;\n\t\t\t\t\tif (_config.preview && _stepCounter > _config.preview)\n\t\t\t\t\t\t_parser.abort();\n\t\t\t\t\telse {\n\t\t\t\t\t\t_results.data = _results.data[0];\n\t\t\t\t\t\tuserStep(_results, self);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Parses input. Most users won't need, and shouldn't mess with, the baseIndex\n\t\t * and ignoreLastRow parameters. They are used by streamers (wrapper functions)\n\t\t * when an input comes in multiple chunks, like from a file.\n\t\t */\n\t\tthis.parse = function(input, baseIndex, ignoreLastRow)\n\t\t{\n\t\t\tvar quoteChar = _config.quoteChar || '\"';\n\t\t\tif (!_config.newline)\n\t\t\t\t_config.newline = guessLineEndings(input, quoteChar);\n\n\t\t\t_delimiterError = false;\n\t\t\tif (!_config.delimiter)\n\t\t\t{\n\t\t\t\tvar delimGuess = guessDelimiter(input, _config.newline, _config.skipEmptyLines, _config.comments, _config.delimitersToGuess);\n\t\t\t\tif (delimGuess.successful)\n\t\t\t\t\t_config.delimiter = delimGuess.bestDelimiter;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_delimiterError = true;\t// add error after parsing (otherwise it would be overwritten)\n\t\t\t\t\t_config.delimiter = Papa.DefaultDelimiter;\n\t\t\t\t}\n\t\t\t\t_results.meta.delimiter = _config.delimiter;\n\t\t\t}\n\t\t\telse if(isFunction(_config.delimiter))\n\t\t\t{\n\t\t\t\t_config.delimiter = _config.delimiter(input);\n\t\t\t\t_results.meta.delimiter = _config.delimiter;\n\t\t\t}\n\n\t\t\tvar parserConfig = copy(_config);\n\t\t\tif (_config.preview && _config.header)\n\t\t\t\tparserConfig.preview++;\t// to compensate for header row\n\n\t\t\t_input = input;\n\t\t\t_parser = new Parser(parserConfig);\n\t\t\t_results = _parser.parse(_input, baseIndex, ignoreLastRow);\n\t\t\tprocessResults();\n\t\t\treturn _paused ? { meta: { paused: true } } : (_results || { meta: { paused: false } });\n\t\t};\n\n\t\tthis.paused = function()\n\t\t{\n\t\t\treturn _paused;\n\t\t};\n\n\t\tthis.pause = function()\n\t\t{\n\t\t\t_paused = true;\n\t\t\t_parser.abort();\n\n\t\t\t// If it is streaming via \"chunking\", the reader will start appending correctly already so no need to substring,\n\t\t\t// otherwise we can get duplicate content within a row\n\t\t\t_input = isFunction(_config.chunk) ? \"\" : _input.substring(_parser.getCharIndex());\n\t\t};\n\n\t\tthis.resume = function()\n\t\t{\n\t\t\tif(self.streamer._halted) {\n\t\t\t\t_paused = false;\n\t\t\t\tself.streamer.parseChunk(_input, true);\n\t\t\t} else {\n\t\t\t\t// Bugfix: #636 In case the processing hasn't halted yet\n\t\t\t\t// wait for it to halt in order to resume\n\t\t\t\tsetTimeout(this.resume, 3);\n\t\t\t}\n\t\t};\n\n\t\tthis.aborted = function()\n\t\t{\n\t\t\treturn _aborted;\n\t\t};\n\n\t\tthis.abort = function()\n\t\t{\n\t\t\t_aborted = true;\n\t\t\t_parser.abort();\n\t\t\t_results.meta.aborted = true;\n\t\t\tif (isFunction(_config.complete))\n\t\t\t\t_config.complete(_results);\n\t\t\t_input = '';\n\t\t};\n\n\t\tfunction testEmptyLine(s) {\n\t\t\treturn _config.skipEmptyLines === 'greedy' ? s.join('').trim() === '' : s.length === 1 && s[0].length === 0;\n\t\t}\n\n\t\tfunction testFloat(s) {\n\t\t\tif (FLOAT.test(s)) {\n\t\t\t\tvar floatValue = parseFloat(s);\n\t\t\t\tif (floatValue > MIN_FLOAT && floatValue < MAX_FLOAT) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction processResults()\n\t\t{\n\t\t\tif (_results && _delimiterError)\n\t\t\t{\n\t\t\t\taddError('Delimiter', 'UndetectableDelimiter', 'Unable to auto-detect delimiting character; defaulted to \\'' + Papa.DefaultDelimiter + '\\'');\n\t\t\t\t_delimiterError = false;\n\t\t\t}\n\n\t\t\tif (_config.skipEmptyLines)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < _results.data.length; i++)\n\t\t\t\t\tif (testEmptyLine(_results.data[i]))\n\t\t\t\t\t\t_results.data.splice(i--, 1);\n\t\t\t}\n\n\t\t\tif (needsHeaderRow())\n\t\t\t\tfillHeaderFields();\n\n\t\t\treturn applyHeaderAndDynamicTypingAndTransformation();\n\t\t}\n\n\t\tfunction needsHeaderRow()\n\t\t{\n\t\t\treturn _config.header && _fields.length === 0;\n\t\t}\n\n\t\tfunction fillHeaderFields()\n\t\t{\n\t\t\tif (!_results)\n\t\t\t\treturn;\n\n\t\t\tfunction addHeder(header)\n\t\t\t{\n\t\t\t\tif (isFunction(_config.transformHeader))\n\t\t\t\t\theader = _config.transformHeader(header);\n\n\t\t\t\t_fields.push(header);\n\t\t\t}\n\n\t\t\tif (Array.isArray(_results.data[0]))\n\t\t\t{\n\t\t\t\tfor (var i = 0; needsHeaderRow() && i < _results.data.length; i++)\n\t\t\t\t\t_results.data[i].forEach(addHeder);\n\n\t\t\t\t_results.data.splice(0, 1);\n\t\t\t}\n\t\t\t// if _results.data[0] is not an array, we are in a step where _results.data is the row.\n\t\t\telse\n\t\t\t\t_results.data.forEach(addHeder);\n\t\t}\n\n\t\tfunction shouldApplyDynamicTyping(field) {\n\t\t\t// Cache function values to avoid calling it for each row\n\t\t\tif (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {\n\t\t\t\t_config.dynamicTyping[field] = _config.dynamicTypingFunction(field);\n\t\t\t}\n\t\t\treturn (_config.dynamicTyping[field] || _config.dynamicTyping) === true;\n\t\t}\n\n\t\tfunction parseDynamic(field, value)\n\t\t{\n\t\t\tif (shouldApplyDynamicTyping(field))\n\t\t\t{\n\t\t\t\tif (value === 'true' || value === 'TRUE')\n\t\t\t\t\treturn true;\n\t\t\t\telse if (value === 'false' || value === 'FALSE')\n\t\t\t\t\treturn false;\n\t\t\t\telse if (testFloat(value))\n\t\t\t\t\treturn parseFloat(value);\n\t\t\t\telse if (ISO_DATE.test(value))\n\t\t\t\t\treturn new Date(value);\n\t\t\t\telse\n\t\t\t\t\treturn (value === '' ? null : value);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tfunction applyHeaderAndDynamicTypingAndTransformation()\n\t\t{\n\t\t\tif (!_results || (!_config.header && !_config.dynamicTyping && !_config.transform))\n\t\t\t\treturn _results;\n\n\t\t\tfunction processRow(rowSource, i)\n\t\t\t{\n\t\t\t\tvar row = _config.header ? {} : [];\n\n\t\t\t\tvar j;\n\t\t\t\tfor (j = 0; j < rowSource.length; j++)\n\t\t\t\t{\n\t\t\t\t\tvar field = j;\n\t\t\t\t\tvar value = rowSource[j];\n\n\t\t\t\t\tif (_config.header)\n\t\t\t\t\t\tfield = j >= _fields.length ? '__parsed_extra' : _fields[j];\n\n\t\t\t\t\tif (_config.transform)\n\t\t\t\t\t\tvalue = _config.transform(value,field);\n\n\t\t\t\t\tvalue = parseDynamic(field, value);\n\n\t\t\t\t\tif (field === '__parsed_extra')\n\t\t\t\t\t{\n\t\t\t\t\t\trow[field] = row[field] || [];\n\t\t\t\t\t\trow[field].push(value);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\trow[field] = value;\n\t\t\t\t}\n\n\n\t\t\t\tif (_config.header)\n\t\t\t\t{\n\t\t\t\t\tif (j > _fields.length)\n\t\t\t\t\t\taddError('FieldMismatch', 'TooManyFields', 'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j, _rowCounter + i);\n\t\t\t\t\telse if (j < _fields.length)\n\t\t\t\t\t\taddError('FieldMismatch', 'TooFewFields', 'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j, _rowCounter + i);\n\t\t\t\t}\n\n\t\t\t\treturn row;\n\t\t\t}\n\n\t\t\tvar incrementBy = 1;\n\t\t\tif (!_results.data.length || Array.isArray(_results.data[0]))\n\t\t\t{\n\t\t\t\t_results.data = _results.data.map(processRow);\n\t\t\t\tincrementBy = _results.data.length;\n\t\t\t}\n\t\t\telse\n\t\t\t\t_results.data = processRow(_results.data, 0);\n\n\n\t\t\tif (_config.header && _results.meta)\n\t\t\t\t_results.meta.fields = _fields;\n\n\t\t\t_rowCounter += incrementBy;\n\t\t\treturn _results;\n\t\t}\n\n\t\tfunction guessDelimiter(input, newline, skipEmptyLines, comments, delimitersToGuess) {\n\t\t\tvar bestDelim, bestDelta, fieldCountPrevRow, maxFieldCount;\n\n\t\t\tdelimitersToGuess = delimitersToGuess || [',', '\\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];\n\n\t\t\tfor (var i = 0; i < delimitersToGuess.length; i++) {\n\t\t\t\tvar delim = delimitersToGuess[i];\n\t\t\t\tvar delta = 0, avgFieldCount = 0, emptyLinesCount = 0;\n\t\t\t\tfieldCountPrevRow = undefined;\n\n\t\t\t\tvar preview = new Parser({\n\t\t\t\t\tcomments: comments,\n\t\t\t\t\tdelimiter: delim,\n\t\t\t\t\tnewline: newline,\n\t\t\t\t\tpreview: 10\n\t\t\t\t}).parse(input);\n\n\t\t\t\tfor (var j = 0; j < preview.data.length; j++) {\n\t\t\t\t\tif (skipEmptyLines && testEmptyLine(preview.data[j])) {\n\t\t\t\t\t\temptyLinesCount++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tvar fieldCount = preview.data[j].length;\n\t\t\t\t\tavgFieldCount += fieldCount;\n\n\t\t\t\t\tif (typeof fieldCountPrevRow === 'undefined') {\n\t\t\t\t\t\tfieldCountPrevRow = fieldCount;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (fieldCount > 0) {\n\t\t\t\t\t\tdelta += Math.abs(fieldCount - fieldCountPrevRow);\n\t\t\t\t\t\tfieldCountPrevRow = fieldCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (preview.data.length > 0)\n\t\t\t\t\tavgFieldCount /= (preview.data.length - emptyLinesCount);\n\n\t\t\t\tif ((typeof bestDelta === 'undefined' || delta <= bestDelta)\n\t\t\t\t\t&& (typeof maxFieldCount === 'undefined' || avgFieldCount > maxFieldCount) && avgFieldCount > 1.99) {\n\t\t\t\t\tbestDelta = delta;\n\t\t\t\t\tbestDelim = delim;\n\t\t\t\t\tmaxFieldCount = avgFieldCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_config.delimiter = bestDelim;\n\n\t\t\treturn {\n\t\t\t\tsuccessful: !!bestDelim,\n\t\t\t\tbestDelimiter: bestDelim\n\t\t\t};\n\t\t}\n\n\t\tfunction guessLineEndings(input, quoteChar)\n\t\t{\n\t\t\tinput = input.substring(0, 1024 * 1024);\t// max length 1 MB\n\t\t\t// Replace all the text inside quotes\n\t\t\tvar re = new RegExp(escapeRegExp(quoteChar) + '([^]*?)' + escapeRegExp(quoteChar), 'gm');\n\t\t\tinput = input.replace(re, '');\n\n\t\t\tvar r = input.split('\\r');\n\n\t\t\tvar n = input.split('\\n');\n\n\t\t\tvar nAppearsFirst = (n.length > 1 && n[0].length < r[0].length);\n\n\t\t\tif (r.length === 1 || nAppearsFirst)\n\t\t\t\treturn '\\n';\n\n\t\t\tvar numWithN = 0;\n\t\t\tfor (var i = 0; i < r.length; i++)\n\t\t\t{\n\t\t\t\tif (r[i][0] === '\\n')\n\t\t\t\t\tnumWithN++;\n\t\t\t}\n\n\t\t\treturn numWithN >= r.length / 2 ? '\\r\\n' : '\\r';\n\t\t}\n\n\t\tfunction addError(type, code, msg, row)\n\t\t{\n\t\t\tvar error = {\n\t\t\t\ttype: type,\n\t\t\t\tcode: code,\n\t\t\t\tmessage: msg\n\t\t\t};\n\t\t\tif(row !== undefined) {\n\t\t\t\terror.row = row;\n\t\t\t}\n\t\t\t_results.errors.push(error);\n\t\t}\n\t}\n\n\t/** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions */\n\tfunction escapeRegExp(string)\n\t{\n\t\treturn string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n\t}\n\n\t/** The core parser implements speedy and correct CSV parsing */\n\tfunction Parser(config)\n\t{\n\t\t// Unpack the config object\n\t\tconfig = config || {};\n\t\tvar delim = config.delimiter;\n\t\tvar newline = config.newline;\n\t\tvar comments = config.comments;\n\t\tvar step = config.step;\n\t\tvar preview = config.preview;\n\t\tvar fastMode = config.fastMode;\n\t\tvar quoteChar;\n\t\t/** Allows for no quoteChar by setting quoteChar to undefined in config */\n\t\tif (config.quoteChar === undefined) {\n\t\t\tquoteChar = '\"';\n\t\t} else {\n\t\t\tquoteChar = config.quoteChar;\n\t\t}\n\t\tvar escapeChar = quoteChar;\n\t\tif (config.escapeChar !== undefined) {\n\t\t\tescapeChar = config.escapeChar;\n\t\t}\n\n\t\t// Delimiter must be valid\n\t\tif (typeof delim !== 'string'\n\t\t\t|| Papa.BAD_DELIMITERS.indexOf(delim) > -1)\n\t\t\tdelim = ',';\n\n\t\t// Comment character must be valid\n\t\tif (comments === delim)\n\t\t\tthrow new Error('Comment character same as delimiter');\n\t\telse if (comments === true)\n\t\t\tcomments = '#';\n\t\telse if (typeof comments !== 'string'\n\t\t\t|| Papa.BAD_DELIMITERS.indexOf(comments) > -1)\n\t\t\tcomments = false;\n\n\t\t// Newline must be valid: \\r, \\n, or \\r\\n\n\t\tif (newline !== '\\n' && newline !== '\\r' && newline !== '\\r\\n')\n\t\t\tnewline = '\\n';\n\n\t\t// We're gonna need these at the Parser scope\n\t\tvar cursor = 0;\n\t\tvar aborted = false;\n\n\t\tthis.parse = function(input, baseIndex, ignoreLastRow)\n\t\t{\n\t\t\t// For some reason, in Chrome, this speeds things up (!?)\n\t\t\tif (typeof input !== 'string')\n\t\t\t\tthrow new Error('Input must be a string');\n\n\t\t\t// We don't need to compute some of these every time parse() is called,\n\t\t\t// but having them in a more local scope seems to perform better\n\t\t\tvar inputLen = input.length,\n\t\t\t\tdelimLen = delim.length,\n\t\t\t\tnewlineLen = newline.length,\n\t\t\t\tcommentsLen = comments.length;\n\t\t\tvar stepIsFunction = isFunction(step);\n\n\t\t\t// Establish starting state\n\t\t\tcursor = 0;\n\t\t\tvar data = [], errors = [], row = [], lastCursor = 0;\n\n\t\t\tif (!input)\n\t\t\t\treturn returnable();\n\n\t\t\tif (fastMode || (fastMode !== false && input.indexOf(quoteChar) === -1))\n\t\t\t{\n\t\t\t\tvar rows = input.split(newline);\n\t\t\t\tfor (var i = 0; i < rows.length; i++)\n\t\t\t\t{\n\t\t\t\t\trow = rows[i];\n\t\t\t\t\tcursor += row.length;\n\t\t\t\t\tif (i !== rows.length - 1)\n\t\t\t\t\t\tcursor += newline.length;\n\t\t\t\t\telse if (ignoreLastRow)\n\t\t\t\t\t\treturn returnable();\n\t\t\t\t\tif (comments && row.substring(0, commentsLen) === comments)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata = [];\n\t\t\t\t\t\tpushRow(row.split(delim));\n\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tpushRow(row.split(delim));\n\t\t\t\t\tif (preview && i >= preview)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata = data.slice(0, preview);\n\t\t\t\t\t\treturn returnable(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn returnable();\n\t\t\t}\n\n\t\t\tvar nextDelim = input.indexOf(delim, cursor);\n\t\t\tvar nextNewline = input.indexOf(newline, cursor);\n\t\t\tvar quoteCharRegex = new RegExp(escapeRegExp(escapeChar) + escapeRegExp(quoteChar), 'g');\n\t\t\tvar quoteSearch = input.indexOf(quoteChar, cursor);\n\n\t\t\t// Parser loop\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\t// Field has opening quote\n\t\t\t\tif (input[cursor] === quoteChar)\n\t\t\t\t{\n\t\t\t\t\t// Start our search for the closing quote where the cursor is\n\t\t\t\t\tquoteSearch = cursor;\n\n\t\t\t\t\t// Skip the opening quote\n\t\t\t\t\tcursor++;\n\n\t\t\t\t\tfor (;;)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Find closing quote\n\t\t\t\t\t\tquoteSearch = input.indexOf(quoteChar, quoteSearch + 1);\n\n\t\t\t\t\t\t//No other quotes are found - no other delimiters\n\t\t\t\t\t\tif (quoteSearch === -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!ignoreLastRow) {\n\t\t\t\t\t\t\t\t// No closing quote... what a pity\n\t\t\t\t\t\t\t\terrors.push({\n\t\t\t\t\t\t\t\t\ttype: 'Quotes',\n\t\t\t\t\t\t\t\t\tcode: 'MissingQuotes',\n\t\t\t\t\t\t\t\t\tmessage: 'Quoted field unterminated',\n\t\t\t\t\t\t\t\t\trow: data.length,\t// row has yet to be inserted\n\t\t\t\t\t\t\t\t\tindex: cursor\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn finish();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Closing quote at EOF\n\t\t\t\t\t\tif (quoteSearch === inputLen - 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);\n\t\t\t\t\t\t\treturn finish(value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If this quote is escaped, it's part of the data; skip it\n\t\t\t\t\t\t// If the quote character is the escape character, then check if the next character is the escape character\n\t\t\t\t\t\tif (quoteChar === escapeChar &&  input[quoteSearch + 1] === escapeChar)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tquoteSearch++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If the quote character is not the escape character, then check if the previous character was the escape character\n\t\t\t\t\t\tif (quoteChar !== escapeChar && quoteSearch !== 0 && input[quoteSearch - 1] === escapeChar)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(nextDelim !== -1 && nextDelim < (quoteSearch + 1)) {\n\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, (quoteSearch + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(nextNewline !== -1 && nextNewline < (quoteSearch + 1)) {\n\t\t\t\t\t\t\tnextNewline = input.indexOf(newline, (quoteSearch + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Check up to nextDelim or nextNewline, whichever is closest\n\t\t\t\t\t\tvar checkUpTo = nextNewline === -1 ? nextDelim : Math.min(nextDelim, nextNewline);\n\t\t\t\t\t\tvar spacesBetweenQuoteAndDelimiter = extraSpaces(checkUpTo);\n\n\t\t\t\t\t\t// Closing quote followed by delimiter or 'unnecessary spaces + delimiter'\n\t\t\t\t\t\tif (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter] === delim)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trow.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n\t\t\t\t\t\t\tcursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen;\n\n\t\t\t\t\t\t\t// If char after following delimiter is not quoteChar, we find next quote char position\n\t\t\t\t\t\t\tif (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen] !== quoteChar)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tquoteSearch = input.indexOf(quoteChar, cursor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline);\n\n\t\t\t\t\t\t// Closing quote followed by newline or 'unnecessary spaces + newLine'\n\t\t\t\t\t\tif (input.substring(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen) === newline)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trow.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n\t\t\t\t\t\t\tsaveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);\n\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\t// because we may have skipped the nextDelim in the quoted field\n\t\t\t\t\t\t\tquoteSearch = input.indexOf(quoteChar, cursor);\t// we search for first quote in next line\n\n\t\t\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (preview && data.length >= preview)\n\t\t\t\t\t\t\t\treturn returnable(true);\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t// Checks for valid closing quotes are complete (escaped quotes or quote followed by EOF/delimiter/newline) -- assume these quotes are part of an invalid text string\n\t\t\t\t\t\terrors.push({\n\t\t\t\t\t\t\ttype: 'Quotes',\n\t\t\t\t\t\t\tcode: 'InvalidQuotes',\n\t\t\t\t\t\t\tmessage: 'Trailing quote on quoted field is malformed',\n\t\t\t\t\t\t\trow: data.length,\t// row has yet to be inserted\n\t\t\t\t\t\t\tindex: cursor\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tquoteSearch++;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Comment found at start of new line\n\t\t\t\tif (comments && row.length === 0 && input.substring(cursor, cursor + commentsLen) === comments)\n\t\t\t\t{\n\t\t\t\t\tif (nextNewline === -1)\t// Comment ends at EOF\n\t\t\t\t\t\treturn returnable();\n\t\t\t\t\tcursor = nextNewline + newlineLen;\n\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Next delimiter comes before next newline, so we've reached end of field\n\t\t\t\tif (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1))\n\t\t\t\t{\n\t\t\t\t\t// we check, if we have quotes, because delimiter char may be part of field enclosed in quotes\n\t\t\t\t\tif (quoteSearch > nextDelim) {\n\t\t\t\t\t\t// we have quotes, so we try to find the next delimiter not enclosed in quotes and also next starting quote char\n\t\t\t\t\t\tvar nextDelimObj = getNextUnquotedDelimiter(nextDelim, quoteSearch, nextNewline);\n\n\t\t\t\t\t\t// if we have next delimiter char which is not enclosed in quotes\n\t\t\t\t\t\tif (nextDelimObj && typeof nextDelimObj.nextDelim !== 'undefined') {\n\t\t\t\t\t\t\tnextDelim = nextDelimObj.nextDelim;\n\t\t\t\t\t\t\tquoteSearch = nextDelimObj.quoteSearch;\n\t\t\t\t\t\t\trow.push(input.substring(cursor, nextDelim));\n\t\t\t\t\t\t\tcursor = nextDelim + delimLen;\n\t\t\t\t\t\t\t// we look for next delimiter char\n\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\trow.push(input.substring(cursor, nextDelim));\n\t\t\t\t\t\tcursor = nextDelim + delimLen;\n\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// End of row\n\t\t\t\tif (nextNewline !== -1)\n\t\t\t\t{\n\t\t\t\t\trow.push(input.substring(cursor, nextNewline));\n\t\t\t\t\tsaveRow(nextNewline + newlineLen);\n\n\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t{\n\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (preview && data.length >= preview)\n\t\t\t\t\t\treturn returnable(true);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\n\t\t\treturn finish();\n\n\n\t\t\tfunction pushRow(row)\n\t\t\t{\n\t\t\t\tdata.push(row);\n\t\t\t\tlastCursor = cursor;\n\t\t\t}\n\n\t\t\t/**\n             * checks if there are extra spaces after closing quote and given index without any text\n             * if Yes, returns the number of spaces\n             */\n\t\t\tfunction extraSpaces(index) {\n\t\t\t\tvar spaceLength = 0;\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tvar textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index);\n\t\t\t\t\tif (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === '') {\n\t\t\t\t\t\tspaceLength = textBetweenClosingQuoteAndIndex.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn spaceLength;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Appends the remaining input from cursor to the end into\n\t\t\t * row, saves the row, calls step, and returns the results.\n\t\t\t */\n\t\t\tfunction finish(value)\n\t\t\t{\n\t\t\t\tif (ignoreLastRow)\n\t\t\t\t\treturn returnable();\n\t\t\t\tif (typeof value === 'undefined')\n\t\t\t\t\tvalue = input.substring(cursor);\n\t\t\t\trow.push(value);\n\t\t\t\tcursor = inputLen;\t// important in case parsing is paused\n\t\t\t\tpushRow(row);\n\t\t\t\tif (stepIsFunction)\n\t\t\t\t\tdoStep();\n\t\t\t\treturn returnable();\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Appends the current row to the results. It sets the cursor\n\t\t\t * to newCursor and finds the nextNewline. The caller should\n\t\t\t * take care to execute user's step function and check for\n\t\t\t * preview and end parsing if necessary.\n\t\t\t */\n\t\t\tfunction saveRow(newCursor)\n\t\t\t{\n\t\t\t\tcursor = newCursor;\n\t\t\t\tpushRow(row);\n\t\t\t\trow = [];\n\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t}\n\n\t\t\t/** Returns an object with the results, errors, and meta. */\n\t\t\tfunction returnable(stopped)\n\t\t\t{\n\t\t\t\treturn {\n\t\t\t\t\tdata: data,\n\t\t\t\t\terrors: errors,\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\tdelimiter: delim,\n\t\t\t\t\t\tlinebreak: newline,\n\t\t\t\t\t\taborted: aborted,\n\t\t\t\t\t\ttruncated: !!stopped,\n\t\t\t\t\t\tcursor: lastCursor + (baseIndex || 0)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t/** Executes the user's step function and resets data & errors. */\n\t\t\tfunction doStep()\n\t\t\t{\n\t\t\t\tstep(returnable());\n\t\t\t\tdata = [];\n\t\t\t\terrors = [];\n\t\t\t}\n\n\t\t\t/** Gets the delimiter character, which is not inside the quoted field */\n\t\t\tfunction getNextUnquotedDelimiter(nextDelim, quoteSearch, newLine) {\n\t\t\t\tvar result = {\n\t\t\t\t\tnextDelim: undefined,\n\t\t\t\t\tquoteSearch: undefined\n\t\t\t\t};\n\t\t\t\t// get the next closing quote character\n\t\t\t\tvar nextQuoteSearch = input.indexOf(quoteChar, quoteSearch + 1);\n\n\t\t\t\t// if next delimiter is part of a field enclosed in quotes\n\t\t\t\tif (nextDelim > quoteSearch && nextDelim < nextQuoteSearch && (nextQuoteSearch < newLine || newLine === -1)) {\n\t\t\t\t\t// get the next delimiter character after this one\n\t\t\t\t\tvar nextNextDelim = input.indexOf(delim, nextQuoteSearch);\n\n\t\t\t\t\t// if there is no next delimiter, return default result\n\t\t\t\t\tif (nextNextDelim === -1) {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\t// find the next opening quote char position\n\t\t\t\t\tif (nextNextDelim > nextQuoteSearch) {\n\t\t\t\t\t\tnextQuoteSearch = input.indexOf(quoteChar, nextQuoteSearch + 1);\n\t\t\t\t\t}\n\t\t\t\t\t// try to get the next delimiter position\n\t\t\t\t\tresult = getNextUnquotedDelimiter(nextNextDelim, nextQuoteSearch, newLine);\n\t\t\t\t} else {\n\t\t\t\t\tresult = {\n\t\t\t\t\t\tnextDelim: nextDelim,\n\t\t\t\t\t\tquoteSearch: quoteSearch\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\n\t\t/** Sets the abort flag */\n\t\tthis.abort = function()\n\t\t{\n\t\t\taborted = true;\n\t\t};\n\n\t\t/** Gets the cursor position */\n\t\tthis.getCharIndex = function()\n\t\t{\n\t\t\treturn cursor;\n\t\t};\n\t}\n\n\n\tfunction newWorker()\n\t{\n\t\tif (!Papa.WORKERS_SUPPORTED)\n\t\t\treturn false;\n\n\t\tvar workerUrl = getWorkerBlob();\n\t\tvar w = new global.Worker(workerUrl);\n\t\tw.onmessage = mainThreadReceivedMessage;\n\t\tw.id = workerIdCounter++;\n\t\tworkers[w.id] = w;\n\t\treturn w;\n\t}\n\n\t/** Callback when main thread receives a message */\n\tfunction mainThreadReceivedMessage(e)\n\t{\n\t\tvar msg = e.data;\n\t\tvar worker = workers[msg.workerId];\n\t\tvar aborted = false;\n\n\t\tif (msg.error)\n\t\t\tworker.userError(msg.error, msg.file);\n\t\telse if (msg.results && msg.results.data)\n\t\t{\n\t\t\tvar abort = function() {\n\t\t\t\taborted = true;\n\t\t\t\tcompleteWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });\n\t\t\t};\n\n\t\t\tvar handle = {\n\t\t\t\tabort: abort,\n\t\t\t\tpause: notImplemented,\n\t\t\t\tresume: notImplemented\n\t\t\t};\n\n\t\t\tif (isFunction(worker.userStep))\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < msg.results.data.length; i++)\n\t\t\t\t{\n\t\t\t\t\tworker.userStep({\n\t\t\t\t\t\tdata: msg.results.data[i],\n\t\t\t\t\t\terrors: msg.results.errors,\n\t\t\t\t\t\tmeta: msg.results.meta\n\t\t\t\t\t}, handle);\n\t\t\t\t\tif (aborted)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdelete msg.results;\t// free memory ASAP\n\t\t\t}\n\t\t\telse if (isFunction(worker.userChunk))\n\t\t\t{\n\t\t\t\tworker.userChunk(msg.results, handle, msg.file);\n\t\t\t\tdelete msg.results;\n\t\t\t}\n\t\t}\n\n\t\tif (msg.finished && !aborted)\n\t\t\tcompleteWorker(msg.workerId, msg.results);\n\t}\n\n\tfunction completeWorker(workerId, results) {\n\t\tvar worker = workers[workerId];\n\t\tif (isFunction(worker.userComplete))\n\t\t\tworker.userComplete(results);\n\t\tworker.terminate();\n\t\tdelete workers[workerId];\n\t}\n\n\tfunction notImplemented() {\n\t\tthrow new Error('Not implemented.');\n\t}\n\n\t/** Callback when worker thread receives a message */\n\tfunction workerThreadReceivedMessage(e)\n\t{\n\t\tvar msg = e.data;\n\n\t\tif (typeof Papa.WORKER_ID === 'undefined' && msg)\n\t\t\tPapa.WORKER_ID = msg.workerId;\n\n\t\tif (typeof msg.input === 'string')\n\t\t{\n\t\t\tglobal.postMessage({\n\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\tresults: Papa.parse(msg.input, msg.config),\n\t\t\t\tfinished: true\n\t\t\t});\n\t\t}\n\t\telse if ((global.File && msg.input instanceof File) || msg.input instanceof Object)\t// thank you, Safari (see issue #106)\n\t\t{\n\t\t\tvar results = Papa.parse(msg.input, msg.config);\n\t\t\tif (results)\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\tresults: results,\n\t\t\t\t\tfinished: true\n\t\t\t\t});\n\t\t}\n\t}\n\n\t/** Makes a deep copy of an array or object (mostly) */\n\tfunction copy(obj)\n\t{\n\t\tif (typeof obj !== 'object' || obj === null)\n\t\t\treturn obj;\n\t\tvar cpy = Array.isArray(obj) ? [] : {};\n\t\tfor (var key in obj)\n\t\t\tcpy[key] = copy(obj[key]);\n\t\treturn cpy;\n\t}\n\n\tfunction bindFunction(f, self)\n\t{\n\t\treturn function() { f.apply(self, arguments); };\n\t}\n\n\tfunction isFunction(func)\n\t{\n\t\treturn typeof func === 'function';\n\t}\n\n\treturn Papa;\n}));\n","export default function getSize(size) {\n  let df = 0\n  let sizeKb = 1024\n  let sizeMb = sizeKb * sizeKb\n  let sizeGb = sizeMb * sizeKb\n  let sizeTerra = sizeGb * sizeKb\n\n  if(size < sizeMb) {\n    return (size / sizeKb).toFixed(0) + ' KB'\n  } else if(size < sizeGb) {\n    return (size / sizeMb).toFixed(0) + ' MB'\n  } else if(size < sizeTerra) {\n    return (size / sizeGb).toFixed(0) + ' GB'\n  }\n\n  return ''\n}\n","import React, { Component } from 'react'\n\nimport PropTypes from 'prop-types'\nimport PapaParse from 'papaparse'\n\nimport getSize from './util'\n\nexport default class CSVReaderRewrite extends Component {\n\n  inputFileRef = React.createRef()\n  dropAreaRef = React.createRef()\n  fileSizeInfoRef = React.createRef()\n  fileNameInfoRef = React.createRef()\n  progressBarFillRef = React.createRef()\n\n  static propTypes = {\n    children: PropTypes.any.isRequired,\n    onDrop: PropTypes.func,\n    onFileLoad: PropTypes.func,\n    onError: PropTypes.func,\n    config: PropTypes.object,\n    style: PropTypes.object,\n    noClick: PropTypes.bool,\n    noDrag: PropTypes.bool,\n    progressBarColor: PropTypes.string,\n  }\n\n  state = {\n    dropAreaStyle: styles.dropArea,\n    hasFiles: false,\n    progressBar: 0,\n    displayProgressBarStatus: 'none',\n    file: '',\n  }\n\n  componentDidMount = () => {\n    const currentDropAreaRef = this.dropAreaRef.current\n\n    const fourDragsEvent = ['dragenter', 'dragover', 'dragleave', 'drop']\n    fourDragsEvent.forEach(item => {\n      currentDropAreaRef.addEventListener(item, this._preventDefaults, false)\n    })\n\n    if (!this.props.noDrag) {\n      const highlightDragsEvent = ['dragenter', 'dragover']\n      highlightDragsEvent.forEach(item => {\n        currentDropAreaRef.addEventListener(item, this._highlight, false)\n      })\n\n      currentDropAreaRef.addEventListener('dragleave', this._unhighlight, false)\n      currentDropAreaRef.addEventListener('drop', this._unhighlight, false)\n      currentDropAreaRef.addEventListener('drop', this._visibleProgressBar, false)\n      currentDropAreaRef.addEventListener('drop', this._handleDrop, false)\n    }\n  }\n\n  _preventDefaults = (e) => {\n    e.preventDefault()\n    e.stopPropagation()\n  }\n\n  _highlight = (e) => {\n    this.setState({dropAreaStyle: Object.assign({}, styles.dropArea, styles.highlight)})\n    this._initializeProgress()\n  }\n\n  _unhighlight = (e) => {\n    this.setState({dropAreaStyle: Object.assign({}, styles.dropArea, styles.unhighlight)})\n  }\n\n  _visibleProgressBar = () => {\n    this.setState({displayProgressBarStatus: 'block'})\n  }\n\n  _handleDrop = (e) => {\n    let files = {}\n    if (e.files === undefined) {\n      const dt = e.dataTransfer\n      files = dt.files\n    } else {\n      files = e.files\n    }\n    this.setState({hasFiles: true}, () => {this._handleFiles(files)})\n  }\n\n  _handleFiles = (files) => {\n    this.setState({progressBar: 0})\n    files = [...files]\n    files.forEach(this._uploadFile)\n  }\n\n  _updateProgress = (percent) => {\n    this.setState({progressBar: percent})\n  }\n\n  _disableProgressBar = () => {\n    this.setState({displayProgressBarStatus: 'none'})\n  }\n\n  _uploadFile = (file, index) => {\n    this._displayFileInfo(file)\n    this.setState({file})\n\n    const {\n      onDrop,\n      onFileLoad,\n      onError,\n      config = {}\n    } = this.props\n\n    const reader = new window.FileReader()\n\n    let options = {}\n\n    if (config.error) {\n      delete config['error']\n    }\n\n    if (config.step) {\n      delete config['step']\n    }\n\n    if (config.complete) {\n      delete config['complete']\n    }\n\n    const size = file.size\n    let data = []\n    let percent = 0\n\n    if (onDrop || onFileLoad) {\n      const self = this\n      options = Object.assign({\n        complete: () => {\n          if (!onDrop) {\n            onFileLoad(data)\n          } else {\n            onDrop(data)\n          }\n        },\n        step: (row, parser) => {\n          data.push(row)\n          const progress = row.meta.cursor\n          const newPercent = Math.round(progress / size * 100)\n          if (newPercent === percent) return\n          percent = newPercent\n          self._updateProgress(percent)\n        },\n      }, options)\n    }\n\n    if (onError) {\n      options = Object.assign({error: onError}, options)\n    }\n\n    if (config) {\n      options = Object.assign(config, options)\n    }\n\n    reader.onload = (e) => {\n      PapaParse.parse(e.target.result, options)\n    }\n\n    reader.onloadend = (e) => {\n      const timeout = setTimeout(() => { this._disableProgressBar() }, 2000)\n    }\n\n    reader.readAsText(file, config.encoding || 'utf-8')\n  }\n\n  _displayFileInfo = (file) => {\n    if (!this._childrenIsFunction()) {\n      this.fileSizeInfoRef.current.innerHTML = getSize(file.size)\n      this.fileNameInfoRef.current.innerHTML = file.name\n    }\n  }\n\n  _handleInputFileChange = (e) => {\n    const { target } = e\n    this.setState({displayProgressBarStatus: 'block'}, () => {this._handleDrop(target)})\n  }\n\n  _initializeProgress = () => {\n    this.setState({progressBar: 0})\n  }\n\n  open = (e) => {\n    if (e) {\n      e.stopPropagation();\n      this.inputFileRef.current.click()\n    }\n  }\n\n  renderChildren = () => {\n    return this._childrenIsFunction() ? this.props.children({file: this.state.file}) : this.props.children\n  }\n\n  _childrenIsFunction = () => {\n    return typeof this.props.children === 'function'\n  }\n\n  render() {\n    \n    const {\n      style,\n      noClick,\n      children,\n      progressBarColor,\n    } = this.props\n\n    return (\n      <>\n        <input\n          type='file'\n          accept='text/csv'\n          ref={this.inputFileRef}\n          style={styles.inputFile}\n          onChange={e => this._handleInputFileChange(e)}\n        />\n        {\n          !this._childrenIsFunction() ? (\n            <div\n              ref={this.dropAreaRef}\n              style={Object.assign({}, style, this.state.dropAreaStyle, noClick ? styles.defaultCursor : styles.pointerCursor)}\n              onClick={noClick ? () => {} : this.open}\n            >\n              {\n                this.state.hasFiles ? (\n                  <div style={Object.assign({}, styles.dropFile, styles.column)}>\n                    <div style={styles.column}>\n                      <span style={styles.fileSizeInfo} ref={this.fileSizeInfoRef} />\n                      <span style={styles.fileNameInfo} ref={this.fileNameInfoRef} />\n                    </div>\n                    <div style={styles.progressBar}>\n                      <span \n                        style={\n                          Object.assign(\n                            {},\n                            styles.progressBarFill,\n                            {\n                              width: `${this.state.progressBar}%`,\n                              display: this.state.displayProgressBarStatus\n                            }\n                          )\n                        }\n                        ref={this.progressBarFillRef}\n                      />\n                    </div>\n                  </div>\n                ) : (\n                  children\n                )\n              }\n            </div>\n          ) : (\n            <div ref={this.dropAreaRef}>\n              {this.renderChildren()}\n              <div style={Object.assign({}, styles.progressBar, {position: 'inherit', width: '100%'})}>\n                <span\n                  style={\n                    Object.assign(\n                      {},\n                      styles.progressBarFill,\n                      {backgroundColor: progressBarColor || '#659cef'},\n                      {\n                        width: `${this.state.progressBar}%`,\n                        display: this.state.displayProgressBarStatus\n                      }\n                    )\n                  }\n                  ref={this.progressBarFillRef}\n                />\n              </div>\n            </div>\n          )\n        }\n      </>\n    )\n  }\n}\n\nconst styles = {\n  dropArea: {\n    border: '2px dashed #ccc',\n    borderRadius: 20,\n    height: '100%',\n    padding: 20,\n    display: 'flex',\n    justifyContent: 'center',\n    alignItems: 'center',\n    flexDirection: 'column',\n  },\n  inputFile: {\n    display: 'none',\n  },\n  highlight: {\n    borderColor: 'purple',\n  },\n  unhighlight: {\n    borderColor: '#ccc',\n  },\n  dropFile: {\n    borderRadius: 20,\n    background: 'linear-gradient(to bottom, #eee, #ddd)',\n    width: 100,\n    height: 120,\n    position: 'relative',\n    display: 'block',\n    zIndex: 10,\n    paddingLeft: 10,\n    paddingRight: 10,\n    position: 'relative',\n  },\n  column: {\n    display: 'flex',\n    justifyContent: 'center',\n    alignItems: 'center',\n    flexDirection: 'column',\n  },\n  progressBar: {\n    width: '80%',\n    borderRadius: 3,\n    boxShadow: 'inset 0 1px 3px rgba(0, 0, 0, .2)',\n    bottom: 0,\n    position: 'absolute',\n    bottom: 14,\n  },\n  progressBarFill: {\n    height: 10,\n    backgroundColor: '#659cef',\n    borderRadius: 3,\n    transition: 'width 500ms ease-in-out',\n  },\n  fileSizeInfo: {\n    backgroundColor: 'rgba(255, 255, 255, 0.4)',\n    padding: '0 0.4em',\n    borderRadius: 3,\n    lineHeight: 1,\n    marginBottom: '0.5em',\n  },\n  fileNameInfo: {\n    fontSize: 14,\n    backgroundColor: 'rgba(255, 255, 255, 0.4)',\n    padding: '0 0.4em',\n    borderRadius: 3,\n    lineHeight: 1,\n  },\n  defaultCursor: {\n    cursor: 'default',\n  },\n  pointerCursor: {\n    cursor: 'pointer',\n  },\n}\n","import PapaParse from 'papaparse'\n\nexport function readString (str, options = {}) {\n  return PapaParse.parse(str, options)\n}\n","import PapaParse from 'papaparse'\n\nexport function readRemoteFile (url, options = {}) { \n  PapaParse.parse(url, Object.assign({}, {download: true}, options))\n}\n","import PapaParse from 'papaparse'\n\nexport function jsonToCSV (json, options = {}) { \n  return PapaParse.unparse(json, options)\n}\n","import PapaParse from 'papaparse'\n\nexport { default as CSVReader } from './CSVReader'\nexport { readString } from './readString'\nexport { readRemoteFile } from './readRemoteFile'\nexport { jsonToCSV } from './jsonToCSV'\n\nexport const BAD_DELIMITERS = PapaParse.BAD_DELIMITERS\nexport const RECORD_SEP = PapaParse.RECORD_SEP\nexport const UNIT_SEP = PapaParse.UNIT_SEP\nexport const WORKERS_SUPPORTED = PapaParse.WORKERS_SUPPORTED\n\nexport const LocalChunkSize = PapaParse.LocalChunkSize\nexport const DefaultDelimiter = PapaParse.DefaultDelimiter\n"]},"metadata":{},"sourceType":"module"}